package pers.fsh.deviceutils.hardware.vectorhardware.mapping;

import com.sun.jna.Structure;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;

/**
 * <i>native declaration : vxlapi.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class s_xl_channel_config extends Structure {
    /**
     * C type : char[31u + 1]
     */
    public byte[] name = new byte[31 + 1];
    /**
     * !< HWTYPE_xxxx (see above)
     */
    public byte hwType;
    /**
     * !< Index of the hardware (same type) (0,1,...)
     */
    public byte hwIndex;
    /**
     * !< Index of the channel (same hardware) (0,1,...)
     */
    public byte hwChannel;
    /**
     * !< TRANSCEIVER_TYPE_xxxx (see above)
     */
    public short transceiverType;
    /**
     * !< transceiver state (XL_TRANSCEIVER_STATUS...)
     */
    public short transceiverState;
    /**
     * !< XL_CHANNEL_CONFIG_ERROR_XXX (see above)
     */
    public short configError;
    /**
     * !< Global channel index (0,1,...)
     */
    public byte channelIndex;
    /**
     * !< Global channel mask (=1<<channelIndex)<br>
     * C type : XLuint64
     */
    public long channelMask;
    /**
     * !< capabilities which are supported (e.g CHANNEL_FLAG_XXX)
     */
    public int channelCapabilities;
    /**
     * !< what buses are supported and which are possible to be
     */
    public int channelBusCapabilities;
    /**
     * Channel<br>
     * !< The channel is on bus
     */
    public byte isOnBus;
    /**
     * !< currently selected bus
     */
    public int connectedBusType;
    /**
     * C type : XLbusParams
     */
    public XLbusParams busParams;
    /**
     * !< introduced for compatibility reasons since EM00056439
     */
    public int _doNotUse;
    public int driverVersion;
    /**
     * !< version of interface with driver
     */
    public int interfaceVersion;
    /**
     * C type : unsigned int[10]
     */
    public int[] raw_data = new int[10];
    public int serialNumber;
    public int articleNumber;
    /**
     * !< name for CANcab or another transceiver<br>
     * C type : char[31u + 1]
     */
    public byte[] transceiverName = new byte[31 + 1];
    /**
     * !< XL_SPECIAL_CAB_XXX flags
     */
    public int specialCabFlags;
    /**
     * !< Dominant Timeout in us.
     */
    public int dominantTimeout;
    /**
     * !< Delay in us.
     */
    public byte dominantRecessiveDelay;
    /**
     * !< Delay in us.
     */
    public byte recessiveDominantDelay;
    /**
     * !< XL_CONNECTION_INFO_XXX
     */
    public byte connectionInfo;
    /**
     * !< XL_CURRENTLY_AVAILABLE_TIMESTAMP...
     */
    public byte currentlyAvailableTimestamps;
    /**
     * !< Minimal Supply Voltage of the Cab/Piggy in 1/100 V
     */
    public short minimalSupplyVoltage;
    /**
     * !< Maximal Supply Voltage of the Cab/Piggy in 1/100 V
     */
    public short maximalSupplyVoltage;
    /**
     * !< Maximal supported LIN baudrate
     */
    public int maximalBaudrate;
    /**
     * !< e.g.: XL_FPGA_CORE_TYPE_XXX
     */
    public byte fpgaCoreCapabilities;
    /**
     * !< e.g.: XL_SPECIAL_DEVICE_STAT_XXX
     */
    public byte specialDeviceStatus;
    /**
     * !< like channelBusCapabilities (but without core dependencies)
     */
    public short channelBusActiveCapabilities;
    /**
     * !< compensation for edge asymmetry in ns
     */
    public short breakOffset;
    /**
     * !< compensation for edgdfde asymmetry in ns
     */
    public short delimiterOffset;
    /**
     * C type : unsigned int[3]
     */
    public int[] reserved = new int[3];

    public s_xl_channel_config() {
        super(1);
    }

    /**
     * 将字节数组转换为字符串，移除NULL终止符
     */
    private static String byteArrayToString(byte[] bytes) {
        if (bytes == null) {
            return "null";
        }

        // 找到第一个NULL终止符
        int length = 0;
        while (length < bytes.length && bytes[length] != 0) {
            length++;
        }

        try {
            return new String(bytes, 0, length, StandardCharsets.UTF_8);
        } catch (Exception e) {
            return "Invalid String: " + Arrays.toString(bytes);
        }
    }

    protected List<String> getFieldOrder() {
        return Arrays.asList("name", "hwType", "hwIndex", "hwChannel", "transceiverType", "transceiverState", "configError", "channelIndex", "channelMask", "channelCapabilities", "channelBusCapabilities", "isOnBus", "connectedBusType", "busParams", "_doNotUse", "driverVersion", "interfaceVersion", "raw_data", "serialNumber", "articleNumber", "transceiverName", "specialCabFlags", "dominantTimeout", "dominantRecessiveDelay", "recessiveDominantDelay", "connectionInfo", "currentlyAvailableTimestamps", "minimalSupplyVoltage", "maximalSupplyVoltage", "maximalBaudrate", "fpgaCoreCapabilities", "specialDeviceStatus", "channelBusActiveCapabilities", "breakOffset", "delimiterOffset", "reserved");
    }

    ;

    public String getName() {
        return byteArrayToString(name);
    }

    ;

    public String getTransceiverName() {
        return byteArrayToString(transceiverName);
    }

    @Override
    public String toString() {
        return "s_xl_channel_config {\n" +
                "  name: \"" + byteArrayToString(name) + "\"\n" +
                "  hwType: " + (hwType & 0xFF) + "\n" +
                "  hwIndex: " + (hwIndex & 0xFF) + "\n" +
                "  hwChannel: " + (hwChannel & 0xFF) + "\n" +
                "  transceiverType: " + (transceiverType & 0xFFFF) + "\n" +
                "  transceiverState: " + (transceiverState & 0xFFFF) + "\n" +
                "  configError: " + (configError & 0xFFFF) + "\n" +
                "  channelIndex: " + (channelIndex & 0xFF) + "\n" +
                "  channelMask: 0x" + Long.toHexString(channelMask) + "\n" +
                "  channelCapabilities: 0x" + Integer.toHexString(channelCapabilities) + "\n" +
                "  channelBusCapabilities: 0x" + Integer.toHexString(channelBusCapabilities) + "\n" +
                "  isOnBus: " + (isOnBus & 0xFF) + "\n" +
                "  connectedBusType: " + connectedBusType + "\n" +
                "  busParams: " + (busParams != null ? "\n" + busParams.toString().replaceAll("(?m)^", "    ") : "null") + "\n" +
                "  _doNotUse: " + _doNotUse + "\n" +
                "  driverVersion: 0x" + Integer.toHexString(driverVersion) + "\n" +
                "  interfaceVersion: 0x" + Integer.toHexString(interfaceVersion) + "\n" +
                "  raw_data: " + Arrays.toString(raw_data) + "\n" +
                "  serialNumber: " + serialNumber + "\n" +
                "  articleNumber: " + articleNumber + "\n" +
                "  transceiverName: \"" + byteArrayToString(transceiverName) + "\"\n" +
                "  specialCabFlags: 0x" + Integer.toHexString(specialCabFlags) + "\n" +
                "  dominantTimeout: " + dominantTimeout + " us\n" +
                "  dominantRecessiveDelay: " + (dominantRecessiveDelay & 0xFF) + " us\n" +
                "  recessiveDominantDelay: " + (recessiveDominantDelay & 0xFF) + " us\n" +
                "  connectionInfo: " + (connectionInfo & 0xFF) + "\n" +
                "  currentlyAvailableTimestamps: " + (currentlyAvailableTimestamps & 0xFF) + "\n" +
                "  minimalSupplyVoltage: " + (minimalSupplyVoltage & 0xFFFF) / 100.0 + " V\n" +
                "  maximalSupplyVoltage: " + (maximalSupplyVoltage & 0xFFFF) / 100.0 + " V\n" +
                "  maximalBaudrate: " + maximalBaudrate + "\n" +
                "  fpgaCoreCapabilities: " + (fpgaCoreCapabilities & 0xFF) + "\n" +
                "  specialDeviceStatus: " + (specialDeviceStatus & 0xFF) + "\n" +
                "  channelBusActiveCapabilities: 0x" + Integer.toHexString(channelBusActiveCapabilities & 0xFFFF) + "\n" +
                "  breakOffset: " + (breakOffset & 0xFFFF) + " ns\n" +
                "  delimiterOffset: " + (delimiterOffset & 0xFFFF) + " ns\n" +
                "  reserved: " + Arrays.toString(reserved) + "\n" +
                "}";
    }

    public static class ByReference extends s_xl_channel_config implements Structure.ByReference {

    }

    public static class ByValue extends s_xl_channel_config implements Structure.ByValue {

    }
}
