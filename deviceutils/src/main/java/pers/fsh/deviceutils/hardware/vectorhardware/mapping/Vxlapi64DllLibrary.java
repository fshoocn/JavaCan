package pers.fsh.deviceutils.hardware.vectorhardware.mapping;

import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.win32.StdCallLibrary;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;

/**
 * JNA Wrapper for library <b>.\vxlapi64.dll</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Vxlapi64DllLibrary extends StdCallLibrary {
    public static final String JNA_LIBRARY_NAME = "XLDriverLibrary/vxlapi64.dll";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Vxlapi64DllLibrary.JNA_LIBRARY_NAME);
    public static final Vxlapi64DllLibrary INSTANCE = Native.loadLibrary(Vxlapi64DllLibrary.JNA_LIBRARY_NAME, Vxlapi64DllLibrary.class);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_MDI_STRAIGHT = (int) 1;

    ;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_DP83XG710Q1_FIX = (int) 0x0235;

    ;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_QUEUE_OVERFLOW = (short) 0x0100;

    ;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_CHANNEL_CAP_IEEE100T1 = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_BYPASS_INACTIVE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_RETRY_TIME_MAX = (int) 255;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_LINE_LOW = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int RX_FIFO_CANFD_QUEUE_SIZE_MIN = (int) 8192;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NA_CHANGED = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_ON_CRITICAL_UNLOCK = (int) 0x00000006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_SEQ_NUM_STATES_MAX = (int) 200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_RESERVED_FLD = (int) 133;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_FORMAT_ERROR = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NPR_CHANGED = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_BUSLOAD_CTRL = (int) 0x00004000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_STOPPED_DEVICE_MODE = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM54210_FIX = (int) 0x0239;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SPY_FRAMEFLAG_FRAME_CRC_NEW_LAYOUT = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_MOST_SIGNAL_OFF = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NOT_FOUND = (int) 139;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_LIGHT_POWER = (short) 0x0214;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_WRONG_VERSION = (int) 160;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_TYPE_RISING = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SYSTEMLOCK_FLAG = (short) 0x021A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DISCONNECT_NONE = (int) 0x0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_CHANNEL_CAP_IEEE100TX = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_RX_BUFFER_NORMAL_MODE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LIGHT_3DB = (int) 50;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MODE_DEACTIVATED = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_SLOT_IN_WRONG_SEGMENT = (int) 0x010F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_VERSION_2_0 = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_VERSION_2_1 = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_WAKUP_INTERNAL = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_SYNC_FRAMES_BELOWMIN = (byte) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_SWC_OPTO = (int) 0x000C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_LINK_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_SYSTEMLOCK_FLAG = (int) 0x00000080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_PAYLOAD_MAX_SIZE = (short) 1524;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_LATENCY_MEDIUM = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_ENABLED = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_INTEGRATION_CONSISTENCY_CHECK = (int) 0x28;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_TRANSCEIVER = (short) 0x0006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_UNDEFINED_DLC = (byte) 0xff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NO_QUEUE_OVERFLOW = (int) 0x0000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_REMOTE_ALIAS_SIZE = (int) 64;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DATA_VALUE_DIGITAL = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_NIT_FAILURE = (byte) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_BAD_EXE_FORMAT = (int) 137;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_ALLOC_BANDWIDTH = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_DUPLEX_FULL = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_NORMAL_ACTIVE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_NUM_BYTES_MISMATCH = (int) 10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NO_SYSTEM_RESOURCES = (int) 138;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_ACK_ERROR = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NOT_IMPLEMENTED = (int) 117;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_ERROR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_TXMSG_FLAG_WAKEUP = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_EDL = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_STOP = (short) 0x0201;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_SWITCH_HIGHSPEED = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_CANID = (int) 0x0202;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_ABORT_STARTUP = (int) 0x2a;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_MSGFLAG_CRCERROR = (int) 0x81;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CACK_OK = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_CFG_DUPLICATE_SEGMENT_NAME = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_TRANSCEIVER_MODE_NORMAL = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_NONE = (int) 0x0000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ETH_MLB = (int) 0x00040000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_NONE = (String) "";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_CHECKSUM_ENHANCED = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_IPSERVER = (int) 71;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_FIXED_1000 = (int) 9;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_GA_CHANGED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5610 = (int) 65;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_1021_FIX = (int) 0x013D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5614 = (int) 78;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5611 = (int) 70;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_STATUS_INIT_APP_PRESENT = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5612 = (int) 72;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_FR_1080 = (int) 0x0201;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_CAN_H = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_CONFIRMATION = (int) 10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_RX_BUFFER_OVERFLOW = (int) 0x07;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_SYNC_PULSE_OUR_SHARED = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_COLD_NORMAL = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short KLINE_MSG = (short) 0x0024;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DIGITAL_TRIGGER = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_CAN_L = (int) 0x0003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_PARAMS_CANOPMODE_CAN20 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_MASTER_SPDIF_SLAVE = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_LINK_UP = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SYSTEMLOCK_FLAG_SET = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_PASS = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_TCSB = (int) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_RXTX_MA = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_APPLICATION_NOTIFICATION = (short) 0x000F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCARDX = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCARDY = (int) 12;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_TCSA = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5620 = (int) 66;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_TYPE_PORT = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_STREAM_STATE = (short) 0x0226;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_NETWORKHANDLE = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_CHANNEL_STATUS = (short) 0x0520;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_RXBUFFERMODE = (int) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEVICE_CASE_LINE_OUT = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_CLOSED = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_BLOCK = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_AL_ONLY = (int) 0x028f;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_SLOW_MIN = (int) 10500;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_INTERNAL_OVERFLOW = (int) 0x2000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_1AE10MLAN8670_LAN8670_V2 = (int) 0x040B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_GEN_LOCK_ERROR = (short) 0x0216;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_1AE10MLAN8670_BCM89883 = (int) 0x0406;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NOT_SUPPORTED = (int) 205;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UART_PARITY_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_MOST = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_REMOTE_DEVICE_INFO = (int) 16;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_ETH_SWITCH_CAP_TAP_LINK = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_BUSLOAD_COUNTER_TYPE_1_BYTE = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_TX_REQUEST = (int) 0x80;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_TX_FIFO_CLEARED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_MAX_RATE_CORRECTION_REACHED = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_START_CYCLE = (short) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_BR_PAIR_1PAIR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_TRANCEIVER_STATUS = (short) 0x008B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NO_RESOURCES = (int) 152;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_STOPPED_LIGHT_OFF = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_BUSLOAD = (short) 0x0218;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANBOARDXL_PXI = (int) 27;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN8900 = (int) 45;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_RX = (short) 0x0208;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ACK_SWITCH = (short) 0x0511;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_UNLOCK = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_DUTY_FACTOR = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_RXBUFFER = (int) 0x011c;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_MODE_SYNCHRONOUS = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_STREAM_NOT_FOUND = (int) 214;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_TX_MODE_SINGLE_SHOT = (byte) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_ACCESS = (int) 112;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEVICE_CASE_LINE_IN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RX_FIFO_QUEUE_SIZE_MIN = (int) (64 * 1024);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_SLOT_OCCUPIED_BY_OTHER_APP = (int) 0x010E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_SEND_ATTEMPT_MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_BUFFER = (int) 0x012d;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_COLLISION_UNKNOWN = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_SYNC_PULSE = (short) 0x000B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5640 = (int) 89;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_START_PENDING = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_IIBA = (int) 0x00000200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TX_DATA = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX_ERROR_SIMULATION = (short) 0x0551;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5650 = (int) 68;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_SPY_FRAMEFLAG_FRAMING_ERROR = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_USB_SUPERSPEED = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CONNECTOR_RJ45 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_LIGHTLOCK_INIC = (int) 0x00000400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_STREAM_TX_LABEL = (short) 0x0229;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_SWC_NORMAL = (int) 0x0005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_KLINE = (int) (0x00000800 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_SBSB = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_STOPPED = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_FPGA_TS_FIFO_OVERFLOW = (int) 0x0000000E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_RX_SPY_SIZE = (int) 36;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_DUPLEX_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_COMMUNICATION_ERROR = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_SBSA = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_LINE_PULL_UP_ACTIVE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNC_ALLOCTABLE = (int) 0x0112;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_TYPE_FALLING = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_OK_ONE_SUCCESS = (int) 0x00000009;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_RXLIGHT = (int) 0x0117;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPECIAL_REGISTER = (int) 0x010c;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_OVERFLOW = (int) 128;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_EDL_RTR = (int) 0x0204;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_LATENCY_HIGH = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_TWIN_LIN_7269_MAG = (int) 0x0081;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPDIF_LOCK_OFF = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_NETWORK_OFF = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ASYNC_SPY = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_NO_MORE_RESOURCES = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TX_TIMEOUT = (int) 0x40000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_PHY_CONFIG_ABORTED = (int) 0x1103;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_SPY_FRAME = (short) 0x008E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_RTL9000AA = (int) 0x0304;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_FLAG_TAKE_KB2NOT = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RX_ERROR_INVALID_CRC = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_SYNC_AUDIO = (int) 0x011f;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_CRC_ERROR = (int) 0x80;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STOP = (int) 0x0102;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_NET_ON = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int RX_FIFO_CANFD_QUEUE_SIZE_MAX = (int) 524288;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TEMP_CONFIGURED = (int) 0x00000020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_UNSUPPORTED_FEATURE = (int) 0x1106;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_PARAMS_MOST_SPEED_GRADE_25 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_SWC = (int) 0x010B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_SLAVE_ON = (byte) 0xff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCARDXL = (int) 15;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_MDI_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_WAKEUP_LISTEN = (int) 0x11;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_PERR = (int) 0x00000040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LIGHT_FULL = (int) 100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_BUSLOAD = (int) 0x0126;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_COLDSTART_FOLLOWING = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_LATENCY_VERY_HIGH = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_PHY_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_PARITY = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_251 = (int) 0x0101;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1630 = 57;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_DEFAULT_CONFIG = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_NOANS = (short) 0x0017;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_A429_HOLT8455_FIX = (int) 0x0144;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ACCESS_TYPE_RELIABLE = (int) (0x00000001);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_STATUS_CHANNEL_ACTIVATED = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_RETRY_TIME_MIN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_SYNC_ALLOC_INFO = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MODE_ACTIVATED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_DUPLEX_HALF = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_IEEE_802_3 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_DEVICE_INDEX = (int) 0xFFFFFFFFL;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SYNC_ALLOC_INFO = (short) 0x0205;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_LIN = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_88Q2112 = (int) 0x0306;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCASEXL = (int) 21;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_LINE_PULL_UP_NOT_ACTIVE = (int) 0x00000000;
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 20
     */
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UART_PARITY_ODD = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_IGNORE_CHANNEL = (int) -1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LIGHT_OFF = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ERROR_CRC = (int) 136;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_CHANGED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_MTSA = (int) 0x40;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ETH_SPY = (int) 0x00000020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATE_UNKNOWN = (int) 9;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1640 = (int) 59;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1641 = (int) 86;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_SPY_FRAMEFLAG_BUS_ERROR = (byte) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_MTSB = (int) 0x80;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_STREAM_UNDERFLOW = (int) 0x00100000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_ASYNC_RX = (int) 0x1000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W2MAX = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_LATENCY_VERY_LOW = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_SET_WAKEUPID = (byte) (0x01 | 0x02);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_REMOTE_FRAME = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SPY = (short) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_FREQUENCY = (short) 0x0206;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_BUSY = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_WAKEUP_SEND = (int) 0x12;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_OVERRUN = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CACK_NO_RESPONSE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM89811_FIX = (int) 0x0238;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FPGA_CORE_TYPE_CAN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CANFD_RX_EVENT_HEADER_SIZE = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_ON_STABLE_LOCK = (int) 0x00000005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_MAC_ACTIVATION_FAILED = (int) 0x1107;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DISCONNECT_REMOVE_ENTRY = (int) 0x1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_NO_HWSYNC_SUPPORT = (int) 0x00000400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_LINK_ERROR = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_SYNC_AUDIO = (short) 0x0212;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX1161B = (int) 115;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX1161A = (int) 114;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_QUEUE_OVERRUN = (int) 216;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_ADDRNOT = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_FR_1080A_MAG = (int) 0x0203;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_DAIO = (String) "DAIO";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_BUSLOAD_COUNTER_TYPE_2_BYTE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_STREAM_CONN_ERROR = (int) 0x00000009;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MACADDR_OCTETS = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_A429_EV_TAG_BUS_STATISTIC = (short) 0x060F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_READY = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_EXT_MSG_ID = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_INSUFFICIENT_RESOURCES = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UART_PARITY_EVEN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_WRITE_RE_FAILED = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_REGISTER_TEMP_CONNECT = (int) 0x2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SSO_RESULT_NO_RESULT = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_NW_SHUTDOWN = (short) 0x0225;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_ASYNC_TX = (int) 0x0800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_BROADR_REACH = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN3600 = (int) 39;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_DAIO = (int) (0x00000040 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_TYPE_DATA = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_TT_CAN_L = (int) 0x000c;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NO_DATA_DETECTED = (int) 143;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W4MAX = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INTERFACE_VERSION_V2 = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INTERFACE_VERSION_V3 = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ASYNC_MLB = (int) 0x00020000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MODE_FORCE_DEACTIVATE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CONNECTOR_DSUB = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_PAYLOAD_INCREMENT_8BIT = (byte) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_RXHANDLE = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_FLAG_NO_SLEEP_MODE_EVENT = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_TARGETADDRESS = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ACCESS_TYPE_UNRELIABLE = (int) (0x00000000);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_NEW_DATA_TX = (short) 0x0040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_ANALOG_A3 = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_ANALOG_A2 = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_STREAM_OVERFLOW = (int) 0x00200000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_ANALOG_A1 = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W2MIN = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_ANALOG_A0 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_DNOPTO = (int) 0x0003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_BCM89810 = (int) 0x0300;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_BCM89811 = (int) 0x0307;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_CONFIG = (int) 0x0f;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_NET_RBD = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_RX_FIFO_QUEUE_SIZE_MIN = (int) 8192;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1670 = (int) 120;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CANFD_MAX_EVENT_SIZE = (int) 128;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_TJA1100_FIX = (int) 0x0233;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_NORMAL_PASSIVE = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ACK_SIMULATION = (short) 0x0552;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_PAYLOAD_INCREMENT_16BIT = (byte) 16;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_TT_CAN_H = (int) 0x000b;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_TX_FRAME = (short) 0x0082;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DIGITAL_ENABLED = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bMPR = (int) 0x90;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_RECEIVER_BUFFER_FULL = (int) 0x0000000E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_EVENT_SIZE_MAX = (int) 2048;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_BAD_CRC = (int) 0x0000000C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_WRONG_COMMAND = (int) 154;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_SYNC_TX_UNDER = (int) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_WAKEUP_STANDBY = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1050_OPTO = (int) 0x011D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_PREAMBLE_TYPE_ERROR = (int) 0x40;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_ERROR = (short) 0x05ff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERROR_TYPE_5BD_TESTER = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1040_MAG = (int) 0x0039;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_7269_MAG = (int) 0x0027;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM89810_FIX = (int) 0x0232;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_RX_UNEXPECTED = (short) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_NM_VECTOR = (short) 0x008A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_RX_EVENT_HEADER_SIZE = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_BIPHASE_ERROR = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_SLOT_ID_INVALID = (int) 0x010B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX1121 = (int) 73;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_STREAM_RX_BUFFER = (short) 0x0228;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_RX_ELEMENT_HEADER_SIZE = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ACTIVATE_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_LTVB = (int) 0x02000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_MOST150_DEVICEMODE_RETIMED_BYPASS_MASTER = (byte) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_PARITY_DISABLED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_PDU_OUT_OF_MEMORY = (int) 0x0104;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_LTVA = (int) 0x00020000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_AQR115C = (int) 0x0480;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String DriverNotifyMessageName = (String) "VectorCanDriverChangeNotifyMessage";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_RTL9000AA_FIX = (int) 0x0237;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_ANALOG_INPUT = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_COLLISION_WUP = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MDR_CHANGED = (int) 0x0040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MUTE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1041_OPTO = (int) 0x0011;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DIRECTION_TX = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_B10011S = (int) 0x000D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_QUEUE_OVERFLOW = (int) 0x8000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_5000 = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_ON = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX1135 = (int) 104;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MAX_EVENT_SIZE = (int) 512;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_TJA1101 = (int) 0x0308;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_TJA1100 = (int) 0x0303;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_PORTHANDLE = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_REMOTE_READ = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_GLITCH_FILTER_MIN = (int) 50;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX1131 = (int) 75;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ERROR_SWITCH = (short) 0x0507;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_PHY_NOT_CONFIGURED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1462BT = (int) 0x0149;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SYSTEMLOCK_FLAG_NOT_SET = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_STREAM_NAME = (int) 212;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_RECEIVE_MSG = (short) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ADD_FRAME_HEADER = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_CTRL_OS8104A = (int) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_ALLOCTABLE = (int) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERROR_TYPE_5BD_ECU = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_EF = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXPRI = (int) 0xC0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CONNECTOR_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_RESOURCE_ALLOCATE = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_PAYLOAD_PREAMBLE = (short) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SPDIF_ERR_NO_ERROR = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_QUEUE_OVERFLOW = (short) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CONNECTION_BROKEN = (int) 210;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_SLEEP = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_REQ_NOT_ACCEP = (int) 141;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_7259_FIX = (int) 0x0159;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_PARAMS_MOST_SPEED_GRADE_150 = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_COUNTER_TYPE_1_BYTE = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_TXMSG_FLAG_RTR = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_ADDR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SPDIF_MODE_SLAVE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_CHAN_INDEX = (int) 111;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_FAST_MAX = (int) 110000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_SWITCHID = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DIRECTION_RX = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_SYNC_AUDIO_EX = (int) 0x012a;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_SPY_FRAMEFLAG_HEADER_CRC_ERROR = (byte) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_IOBA = (int) 0x00000400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_TIMER_EVENT = (short) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NOTIFY_REASON_CHANNEL_ACTIVATION = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_NO_NET_SEARCH = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NDR_CHANGED = (int) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RAW_FRAME_SIZE_MAX = (int) 1600;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_GAP_4BIT = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_J1708 = (String) "J1708";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_EVENTSOURCE = (int) 0x0040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_NACK_ERROR = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_PDU_NO_UNMAP_OF_SYNCFRAME = (int) 0x0116;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_RESERVED_1 = (int) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_252 = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_5000BASE_T1 = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_251 = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BR_SGMII_DP83XG710Q1 = (int) 0x0305;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INIT_ACCESS_MISSING = (int) 158;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_NET_SEARCH = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_MOST150_ONBOARD = (int) 0x0220;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_ANALOG_RANGE_32V = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LIGHT_MODULATED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_GAP_MAX = (int) 0x000FFFFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_AUTO_BAUDRATE_ENABLED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ECL_SEQUENCE = (short) 0x022D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_ETH_SWITCH_CAP_REALSWITCH = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CLOCK_AUTO = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_SWC = (int) 0x0006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_NONE = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_ETHPORTHANDLE = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_ERROR_FRAME = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_APPNAME = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int MAX_MSG_LEN = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_LATENCY_HIGH = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DATA_VALUE_ANALOG = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_OFFLINE = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_3DB = (int) 0x00000032;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_RX_DATA = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_ESI = (int) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_STATUS_POWER_GOOD = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_TIME_SYNC_RUNNING = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_100 = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_TX_ERROR = (short) 0x0402;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1041A_MAG = (int) 0x0138;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104_TX_LOCK_ERROR = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SPY_MODE_ASYNCHRONOUS = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CL_DEALLOC_ALL = (int) 0x00000FFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN0601 = (int) 87;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_CHANNEL_INDEX = (int) 0xFFFFFFFFL;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_RX_ERROR_INVALID_LENGTH = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_DAIO_8642 = (int) 0x0280;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DO_LEVEL_0V = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_DAIO_8644 = (int) 0x0281;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_PHY_IEEE = (short) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_STANDARD_PC = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TX = (int) 0x010f;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_TRANSCEIVER_INFO = (short) 0x0006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_QUEUE_UNDERRUN = (int) 0x00000015;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LOCK = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_RECEIVED_HEADER = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_LATENCY_LOW = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_VT = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_FIBER = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_WRONG_PARAMETER = (int) 101;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_A429 = (int) 0x00002000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_QUEUE_OVERFLOW_ASYNC = (int) 0x0800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ETHERNET_TX_ACK = (short) 0x021F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_VX = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_VN = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_RX_MAX = (int) 120000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_10000BASE_T1 = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_STARTED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_TAG = (int) 132;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_SYNCLINE = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_FLAG_ON_REQUEST = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_RX_FIFO_QUEUE_SIZE_MAX = (int) 524288;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_FAMILY_NETWORK = (int) (1 << 24);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_ETH_1000BASET1_88Q2112 = (int) 0x1F83;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_TX_COMPLETED = (int) 0x40;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_MASTER = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_RTR = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_TX_BYTES_PER_FRAME_MAX = (int) 152;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_QUEUE_OVERFLOW_DRV = (int) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_GAP_VIOLATION = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_CTRL_SPY = (int) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_REGISTER_BYTES = (int) 0x010a;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MAC_ADDR_CHANGED = (int) 0x00000200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_SPY = (short) 0x021C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_CL_DISAPPEARED = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_MTS = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104_ASYNC_BUFFER_FULL = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_ETH_SWITCH_CAP_DIRECTCONN = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_FIXED_10 = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_STREAM_RX_DATA = (int) 0x00400000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1040_MAG = (int) 0x0137;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_RX_OVERFLOW_ERROR = (int) 0x0000000D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_LIGHTLOCK_SPY = (int) 0x00000200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEVICE_SPDIF_IN_OUT_SYNC = (int) 11;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYNC_PULSE_OUR = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_INVALID_FRAME = (short) 0x0084;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_A429 = (String) "ARINC429";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_BCM89883_2CH = (int) 0x0481;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_QUEUE_IS_FULL = (int) 11;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_ASYNC_RX_FIFO_OVER = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_PINDEX = (int) 0x00000020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHIPSTAT_ERROR_WARNING = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SPDIFMODE = (short) 0x0220;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CONNECTOR_DEFAULT = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VX0312 = (int) 91;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_NISTATE_NOT_NETON = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_NBR_FRAMES_OVERFLOW = (int) 0x0109;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYNC_PULSE_EXTERNAL = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERROR_TYPE_FI = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SHUTDOWN_FLAG_NOT_SET = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_NERR = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_TX_ERROR_PHY_NOT_CONFIGURED = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_COMESFROM_SLEEPMODE = (byte) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_CRCINFO = (short) 0x001A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_LOSTEVENT = (short) 0x05fe;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_SYNTAX_ERROR = (short) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_MAX_OFFSET_CORRECTION_REACHED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_ON_UNLOCK = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_A429 = (int) (0x00002000 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RAW_FRAME_SIZE_MIN = (int) 24;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_CAS = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_RX_NUM_CL_MAX = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TXLIGHT_POWER = (int) 0x0123;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DO_LEVEL_5V = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_AUTO_100_1000 = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_REMOVED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_FAMILY_USB = (int) (0 << 24);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_TO_LONG = (int) 0x0E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W4MIN = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_NET_OFF = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_STREAM_ALREADY_STARTED = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_STARTED = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_CRC = (int) 0x00000080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_FLEXRAY = (String) "FlexRay";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_AUTO_1000 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_CLOSED = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONFIG_MAX_CHANNELS = (int) 64;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_COLDSTART_CONSISTENCY_CHECK = (int) 0x23;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ECL_CHANGE = (int) 0x00000800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_NW_STARTUP = (short) 0x0224;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_A429_EV_TAG_RX_ERR = (short) 0x0609;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_TYPE_FILLUP_NF = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SSO_RESULT_CRITICAL_UNLOCK = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VT6204 = (int) 77;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_STATUS_EXT_POWER_GOOD = (int) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_7269_FIX = (int) 0x0147;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_LENGTH = (int) 31;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_MODULATED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_TX_NOT_POSSIBLE = (int) 12;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_ETHERNET = (int) (0x00001000 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_PARAMS_CANOPMODE_CANFD = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_REGISTER_NONE = (int) 0x0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CLOCK_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5610A = (int) 101;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_OFF = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_RX_BUFFER_TYPE_CTRL = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104_ASYNC_CRC_ERROR = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VOLUME_MAX = (int) 0x000000FF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UART_PARITY_MARK = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_NET_RBD_RESULT = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bMDR = (int) 0x91;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int MOST150_SYNC_ALLOC_INFO_SIZE = (int) 372;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN7600 = (int) 41;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_NO_LOCK = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_10 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CLOCK_MASTER = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_PHY_BROADR = (short) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_CHANNEL_DIR_RX = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5430 = (int) 109;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_PHY_BRIDGE_ENABLED = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_TIMEOUT = (int) 0x00000005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1041 = (int) 0x011F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_ASYNC_SPY = (int) 0x8000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_POLLING_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_FAST_MIN = (int) 90000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_XTIM_CHANGED = (int) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_COUNTER_TYPE_4_BYTE = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1050_OPTO = (int) 0x000F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_TYPE_MASK_DIGITAL = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_CAN = (String) "CAN";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_CONVERTER_RESET = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN7610 = (int) 81;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_TRANSMITTED = (int) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_TX_ACK = (short) 0x0209;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_STARTUP_SUCCESS = (int) 0x2b;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_OTHER_ERROR = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_UNDEFINED = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_RX_OS8104 = (int) 0x010e;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN8950 = (int) 47;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int RX_FIFO_MOST_QUEUE_SIZE_MAX = (int) 1048576;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_ETHERTYPE_OCTETS = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_DLL_NOT_FOUND = (int) 203;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_TX_DATA = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CONFIGURE_RX_BUFFER = (short) 0x0211;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VT6204B = (int) 90;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DATA_PWM = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_CONFIGURED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_PARITY_EVEN = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_PHY_BROADR_REACH = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_CRCCALCULATED = (int) 0x00000100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_QUEUE_OVERFLOW = (int) 0x100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ETHERNET_RX = (short) 0x0219;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_ERROR = (int) 9;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_IEEE_SGMII_AR8031 = (int) 0x0302;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_PORT_ACCESS_TYPE = (int) 147;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_SLAVE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_AUTO_BAUDRATE_DISABLED = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_POC_ACTIVE = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_RX_ERROR_INVALID_CRC = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_REGISTER_CONNECT = (int) 0x1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_KB1 = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_STREAM_TX_BUFFER = (short) 0x0227;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_KB2 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_VIRTUAL = (int) 0x0016;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_NOT_ENOUGH_DATA = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_6259_MAG = (int) 0x012D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_RX_BUFFER_CLEAR_ONCE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_WUP_RECEIVED_WITHOUT_WUS_TX = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_EXT = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_SYNC_FRAMES_OVERLOAD = (byte) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_APA_CHANGED = (int) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_FIXED_100 = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_TX_MSG = (short) 0x0440;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_7269_MAG = (int) 0x0133;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_EVENT_SOURCE = (short) 0x0203;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_NETWORKID = (int) (-1);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FPGA_CORE_TYPE_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CONNECTOR_DSUB = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_CONFIG_NOT_OK = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_STOP_PENDING = (int) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN8972 = (int) 85;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN7640 = (int) 102;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_STDBY = (int) 0x000a;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN8970 = (int) 61;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM84891_FIX = (int) 0x023B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCASEXL_LOG_OBSOLETE = (int) 23;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_DAIO_8444_OPTO = (int) 0x0139;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_MDI_AUTO = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_CANFD_ISO_SUPPORT = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_TX_MODE_NONE = (byte) 0xff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_ANALOG_ENABLED = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_SOURCEADDRESS = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM54810_89811_FIX = (int) 0x0234;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1041A_MAG = (int) 0x003B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_NO_MORE_BUFFERS_AVAILABLE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_VN8900 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_TX_BYTES_PER_FRAME_MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_OPEN_PENDING = (int) 0x07;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ALLOC_BANDWIDTH_NUM_CL_MAX = (int) 10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_PDU_PAYLOAD_SIZE_INVALID = (int) 0x0107;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_ANALOG_OUT = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MPR_CHANGED = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TX_WHILE_UNLOCKED = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INTERFACE_VERSION = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_RX_MIN = (int) 10000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_START = (short) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANBOARDXL = (int) 25;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_SESB = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYMBOL_STATUS_SESA = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_RESOURCE_DEALLOCATE = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_LIN_CALC_CHECKSUM = (short) 0x100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MPR_SPY_CHANGED = (int) 0x00000800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_STAYALIVE = (byte) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_FAMILY_MASK = (int) 0xff000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_CLOSE_PENDING = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CHANNEL_A = (short) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_J1708 = (int) 0x00000100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CHANNEL_B = (short) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CTRL_RETRY_PARAMS_CHANGED = (int) 0x00000060;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_SWC_PROTO = (int) 0x0005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5240 = (int) 64;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_AR8031_FIX = (int) 0x0231;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_STARTED = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ERROR_MEASUREMENT = (short) 0x0563;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_FREQUENCY_ERROR = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_DAIO = (int) 0x00000040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1054_MAG = (int) 0x013B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_CONNECION_REFUSED = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXRTY = (int) 0xBF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_FREQUENCY_ERROR = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_BAUDRATE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_UNKNOWN_TYPE = (int) 0x00000012;
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 4
     */
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_FRC_1082_CAP = (int) 0x0205;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RX_FIFO_QUEUE_SIZE_MAX = (int) (64 * 1024 * 1024);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_CHANNEL_DIR_TX = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_SEND_ATTEMPT_MAX = (int) 16;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RX_ERROR_PHY_ERROR = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_5BD_KB2NOT = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BCM84891 = (int) 0x0403;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LIGHT_FORCE_ON = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_NIT_SENB = (int) 0x400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_NIT_SENA = (int) 0x100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_EVT_ID_ANALOG = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_7259_MAG = (int) 0x0025;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_STATUS = (short) 0x0088;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_SYNC = (short) 0x0002;
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 36
     */
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1057_FIX = (int) 0x0146;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_MVQ3244 = (int) 0x040A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_PARITY_ERROR = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_88Q2220M_FIX = (int) 0x023D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CHIP_STATE = (short) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_ETHERNET = (String) "Ethernet";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXTYP = (int) 0xC1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_SRR_BIT_DOM = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_251_MAG = (int) 0x0035;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_QUEUE_OVERFLOW = (short) 0x0100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_SYNC_FRAME_MODE = (int) 0x0123;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_TWIN_CAN_1054_1041A_MAG = (int) 0x0083;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_MDI_CROSSOVER = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_STOPPED = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN4610 = (int) 105;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_WRONG_CHIP_TYPE = (int) 153;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CTRL_SEND_ATTEMPT_MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_FLAG_CYCLIC = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_CHECKSUM_CLASSIC = (byte) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_VOLUMEMUTE = (int) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_PARITY_ODD = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_COUNTER_TYPE_NONE = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_EVENT_MAX_SIZE = (int) (32 + 1024);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_RX_DATA = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_RX_EVENT_HEADER_SIZE = (short) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERROR_TYPE_IBS = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_SLAVE_OFF = (byte) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int RX_FIFO_MOST_QUEUE_SIZE_MIN = (int) 8192;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SBC_CHANGED = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_INIC_BUSY = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_CLOCK_SLAVE = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VOLUME_MIN = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_WAKEUP = (short) 0x0085;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CMD_HANDLING = (int) 122;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_FRAME_CYCLE_MULTIPLEX_ERROR = (int) 0x0110;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FPGA_CORE_TYPE_LIN_RX = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_FREQUENCY_44100 = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_OPENED = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_TIME_MIN = (int) 10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_GAP_DEFAULT = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_BITRATE_HIGH = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_SUCCESS = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_6259_OPTO = (int) 0x012B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_ANALOG_DIFF = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ETHERNET_SEND_PAYLOAD_MAX_SIZE = (short) 1600;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_HANDLE = (int) 155;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_FLEXRAY = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNC_TX_UNDERFLOW = (int) 0x011d;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_MOST150_DEVICEMODE_RETIMED_BYPASS_SLAVE = (byte) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_FREQUENCY_44100 = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_CHANNEL_CAP_IEEE1000T = (int) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_1021_FIX_WITH_AL = (int) 0x0290;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ERROR = (short) 0x0210;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_DETAIL_MASK = (int) 0x00ffffff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_SPECIAL_NODE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN3300 = (int) 37;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_CAN = (int) (0x00000001 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_ALL_CL_MISSING = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_BUSLOAD_COUNTER_TYPE_NONE = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_DLC = (int) 0x0201;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_LIGHT_STRESS = (int) 0x00001000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_BYPASS_CLOSED = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_SYNC_PULSE_OUR_SHARED = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TESTER_FI_WU_PATTERN = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_INVALID_LENGTH = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_OVERFLOW_ERROR = (int) 0x0000000F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_ECU_FI_WU_PATTERN = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TXLIGHT = (int) 0x0118;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_TWICE_REGISTER = (int) 110;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_LIN = (String) "LIN";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_LIGHTLOCK = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_MSG = (int) 0x0110;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VH6501 = (int) 94;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_TYPE_QUEUE_OVERFLOW = (int) 0x00000011;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_DIGITAL_PUSHPULL = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int MOST_ALLOC_TABLE_SIZE = (int) 64;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_WAKEUP_AND_COLDSTART_LEADING = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_PAYLOAD_SIZE_MIN = (int) 46;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_TYPE_CYCLIC = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_TX_MSG_CTRL_ON_REQUEST = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_SIZE = (int) 134;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CMD_TX_UNDERRUN = (int) 0x00000009;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_STATUS_VALID_CFG_MODE = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_TX_ERROR_BYPASS_ENABLED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_ADDRESS = (int) 140;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_OUTPUT_MODE_TX_OFF = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPECIAL_REGISTER_CHANGE_SIZE = (int) 20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_CL_MISSING = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERROR_TYPE_RXTX_ERROR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_BITRATE_LOW = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_COMM_PARAM_ECU = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_MSGFLAG_TX = (int) 0x40;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TESTER_5BD = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NO_MUTE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_START = (int) 0x0101;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_SLAVE_SPDIF_SLAVE = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_MODE_ANALOG_ASCENDING = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_ERROR = (short) 0x0087;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SSO_RESULT = (short) 0x022F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_MODE_DIGITAL = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ERROR_ASYNC_TX_ACK_HANDLE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_CHANNEL_A = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_NIT_SBNA = (int) 0x200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_CHANNEL_B = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_251_OPTO = (int) 0x0105;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1054_OPTO = (int) 0x0115;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_QUEUE_IS_EMPTY = (int) 10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_NIT_SBNB = (int) 0x800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_REMOTE_WRITE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_INVALID_HANDLE = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_STOP_PENDING = (int) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MCU_TS_CMD_QUEUE_OVERRUN = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_RX_DATA_SIZE = (int) 1028;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_AFDX = (String) "AFDX";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int SYNC_PULSE_EXTERNAL = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_POC_MODE = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_TESTERRESISTOR_OFF = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_SBC_ERROR = (int) 0x0C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_VLANTAG_OCTETS = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_MOST = (String) "MOST";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ACTIVATE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_INSERTED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_ECU_5BD = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SBC_SPY_CHANGED = (int) 0x00001000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_7259 = (int) 0x014A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_NPR_CHANGED = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_HALT = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_ETHERNET = (int) 0x00001000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ETHERNET_PAYLOAD_MAX_SIZE = (short) 1506;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_NOT_SUPPORTED = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_7259_MAG = (int) 0x0131;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_INVALID_HANDLE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_PAYLOAD_MAX_SIZE = (short) 45;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_SWC_7356_CAP = (int) 0x0140;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ACK_OTHER_APP = (short) 0x0513;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_DUPLEX_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1054_OPTO = (int) 0x000B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1057_CAP = (int) 0x0142;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_SUPERVISOR_MESSAGE = (int) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_MHF = (int) 0x00000800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_FR_1082_CAP_FIX = (int) 0x0206;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SHUTDOWN_NO_ERRORINFO = (int) 0xFFFFFFFFL;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_ETH_100BASET1_TJA1101 = (int) 0x1F82;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_IBS_P4 = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_SPDIF_CAPABLE = (int) 0x00004000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_POC_COMM_HALT = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_IBS_P1 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_AL_WU = (int) 0x0291;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MSG_FLAG_WAKEUP = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ERROR_UNKNOWN_COMMAND = (int) 0x0000000C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_DIGITAL_OPENDRAIN = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_TE = (int) 0x4000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_NO_LIGHT = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_RX_ERROR = (short) 0x0401;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_MACADDR_ERROR = (int) 0x00000040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SHUTDOWN_FLAG = (short) 0x021B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_SPY_CHANNEL_A = (short) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_SPY_CHANNEL_B = (short) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN8800 = (int) 95;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_CACK = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_MOST = (int) (0x00000010 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_VERSION_1_3 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_USB_HIGHSPEED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bGA = (int) 0x89;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_SLOT_BOUNDARY_VIOLATION = (short) 0x0800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_DIGITAL_IN_OUT = (int) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SPECIAL_NODE_INFO = (short) 0x0207;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_NAME_LENGTH = (int) 48;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TX_UNDERRUN = (int) 0x00000006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bRSAL = (int) 0xA2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W1MAX = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_INIC = (short) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_CHANNEL_CAP_IEEE1000T1 = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1050 = (int) 0x011B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bRSAH = (int) 0xA1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_PORT = (int) 118;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_MODE_PULSE = (int) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1054 = (int) 0x0103;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_BUSY = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CC_COLD_AB = (short) (0x04 | 0x08);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_MESSAGE_LENGTH_ERROR = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_TXACK_MLB = (int) 0x00080000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_SPDIF_IN = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEVICE_SPDIF_IN = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_WAKEUP_AND_COLDSTART_FOLLOWING = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_NET_INIT = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_TXACK_SS = (short) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1051HG_CAP = (int) 0x0145;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SSO_RESULT_NO_FAULT_SAVED = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_ANALOG_IN = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_CONFIGURE_ECU = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_NO_LINK = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ECL_LINE_CHANGED = (short) 0x0222;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_CTRL_SPY = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CHAN_IS_ONLINE = (int) 116;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_BCM54210 = (int) 0x0482;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ERROR = (int) 0x011a;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CTRL_SEND_ATTEMPT_MAX = (int) 16;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_BUSLOAD_COUNTER_TYPE_4_BYTE = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_DEVICE_MODE = (short) 0x0204;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final long XL_ALL_REMOTE_DEVICES = (long) 0xFFFFFFFFL;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_SLOT_ALREADY_OCCUPIED_BY_ERAY = (int) 0x010C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_RX_ERROR_MACADDR_ERROR = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ETHERNET_INVALID_RX_LENGTH = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_EVA = (int) 0x0007;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SYNC_VOLUME_STATUS = (short) 0x020D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN2600 = (int) 29;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_EDL_NOT_SET = (int) 0x0205;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_LINK_DOWN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W3MAX = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNCPULSE_ERROR = (int) 0x0000000A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SSO_RESULT_SUDDEN_SIGNAL_OFF = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_MASTER = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_LINE_IN = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_FLEXRAY = (int) (0x00000004 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_OPENED = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_UNLOCK = (int) 0x0F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_WAKEUP = (short) 0x0018;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ACK = (short) 0x0510;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_WRONG_BUS_TYPE = (int) 202;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_FR_RESERVED = (short) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_CL_MAX = (int) 0x017F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_LATENCY_VERY_HIGH = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_RX = (short) 0x020B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_NO_ERROR = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN2610 = (int) 29;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bSBC = (int) 0x96;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_PAYLOAD_SIZE_MAX = (int) 1500;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_100BASE_T1 = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_TRANSCEIVER_MODE_SLEEP = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_TYPE_DATA_PACKET = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_DIGITAL_SWITCH = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ACTIVATE_RESET_CLOCK = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_STATUS_NOT_SUPPORTED = (int) 0x0040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_CTRL_BUSLOAD = (short) 0x0217;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_88Q2112_FIX = (int) 0x023A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_RX_ERROR_INVALID_LENGTH = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_DUPLEX_AUTO = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_SWC_SLEEP = (int) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ERROR_EV_SIZE = (int) 16;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1530 = (int) 112;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1531 = (int) 113;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_2500BASE_T1 = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_MODE_NONE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNC_VOLUME_STATUS = (int) 0x0116;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_BR_PAIR_1PAIR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_UNKNOWN_TYPE = (int) 0x00000014;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_RX_ERROR_PHY_ERROR = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_NO_ERROR = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_ANALOG_OFF = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE = (int) 0x012c;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_TXACK_FRAME = (short) 0x0083;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXCD0 = (int) 0xC4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1050_MAG = (int) 0x0136;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_88Q2112 = (int) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_MODE_ASYNCHRONOUS = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_TX_BUFFER_UNDERRUN = (int) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_TX_ERROR_ACCESS_DENIED = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_88Q2221M = (int) 0x0408;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_MAX_EVENT_DATA_SIZE = (int) 2048;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_INIC_SC_ERROR = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_SYNC_PULSE_OUR = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_SWC_WAKEUP = (int) 0x0007;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_TX_ACK = (short) 0x021D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_DATA_UPDATE_LOST = (short) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ERROR_OTHER_APP = (short) 0x0514;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1630_LOG = (int) 79;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DO_LEVEL_12V = (int) 12;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_QUEUE_OVERFLOW_CTRL = (int) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_FORM_ERROR = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_PORT_IS_OFFLINE = (int) 113;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_SLOT_ALREADY_OCCUPIED_BY_COLDC = (int) 0x010D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_6258_OPTO = (int) 0x0017;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CONNECTION_FAILED = (int) 213;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MCU_TS_CMD_QUEUE_UNDERRUN = (int) 0x00000007;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_SET_SILENT = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_ETH_SWITCH_CAP_MULTIDROP = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_PACK_OK = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DIGITAL_INPUT = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_BYPASS_MACCORE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CTRL_RETRY_TIME_MAX = (int) 31;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_TX_ERROR_TRANSMISSION_ERROR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_A429_EV_TAG_TX_ERR = (short) 0x0601;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_FR_1082_CAP = (int) 0x0204;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bRTYP = (int) 0xA0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_MASTER_FROM_SPDIF_SLAVE = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN2640 = (int) 53;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_FILTER_TYPE_NF = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_PACK_BUFFER_FULL = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ERROR = (short) 0x0506;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1055_CAP = (int) 0x0141;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_TT_OPTO = (int) 0x0119;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_FR_CLUSTERCONFIG_MISSING = (int) 0x0105;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_ANY_BUFFER_LOCKED = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_STATUS_MASK = (int) 0x0000003F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_PACK = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SPDIF_MODE_MASTER = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_DUE_TO_NET_OFF = (int) 0x00000006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W1MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_BUSLOAD = (int) 0x0127;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_INVALID_CONFIG_HANDLE = (int) (0);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX_MEASUREMENT = (short) 0x0560;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_RXTX_ISB = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_BYTE_FRAMING_ERROR_MASK = (int) 0x1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_SPECIAL_DEVICE_STAT_FPGA_UPDATE_DONE = (int) 0x01;
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 35
     */
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_TRXMODE_NORMAL = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_SYNCERR = (short) 0x0016;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_TESTERRESISTOR_ON = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_HW_NOT_READY = (int) 120;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_CHECKSUM_UNDEFINED = (byte) 0xff;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_SET_SLEEPMODE = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_SEND_PAYLOAD_MAX_SIZE = (short) 1600;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_ONLINE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_EXTERNAL_WAKEUP = (int) 0x07;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_MONITOR_MODE = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_PRIORITY = (int) 0x00000040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_8444_OPTO = (int) 0x001D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_EVT_TAG_SET_COMM_PARAM_TESTER = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_TX_LIGHT = (short) 0x020E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_DIGITAL_IN = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXTIM = (int) 0xBE;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VTSSERVICE = (int) 110;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104B = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_CTRL_MLB = (int) 0x00010000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_TX_UNDERRUN = (int) 0x00000005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_ON_LOCK = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_SYNC_PULSE_EXTERNAL = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_EXCPT_ERROR = (int) 9;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_NO_MUTE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_CFG_STAT_OK = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STARTUP_NO_ERROR = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_TYPE_BOTH = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_TXMSG_FLAG_BRS = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_MSG = (short) 0x0014;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104_CODING_ERROR = (int) 0x0000000B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_CRC_ERROR = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_TX_ERROR_NO_LINK = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_PHY_ACTIVATION_FAILED = (int) 0x1100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_HW_NOT_PRESENT = (int) 129;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104A = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_COUNTER_TYPE_3_BYTE = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CLOCK_SLAVE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CLOCK_MASTER = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_AVG_BIT_LENGTH = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_COLDSTART_GAP = (int) 0x24;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_TESTER_W3MIN = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_POC_PASSIVE = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM89883_FIX = (int) 0x023C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MEASUREMENT_NOT_ACTIVE = (int) 0x1000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_SLAVE_SPDIF_MASTER = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_LINE_HIGH = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_BUFFER_ERROR_STOP_BY_APP = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int SYNC_PULSE_OUR = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN7570 = (int) 67;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_MODE_ANALOG_DESCENDING = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_251_MAG = (int) 0x0135;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_CFG_DUPLICATE_VP_NAME = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_INTEGRATION_COLDSTART_CHECK = (int) 0x26;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_SWC_FAST = (int) 0x0006;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN7572 = (int) 83;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_QUEUE_UNDERRUN = (int) 0x00000013;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_BYPASS_PHY = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_STOPPED = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_EVENT_FLAG_OVERRUN = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_STARTUP_PREPARE = (int) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_SPY_SYMBOL = (short) 0x008F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_RX_DATA = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_START_PENDING = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_STATE_CHANGE = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_TX_MODE_CYCLIC = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_MODE_ANALOG = (int) (0x00000002 | 0x00000004);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_LATENCY_VERY_LOW = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CSMCAN = (int) 98;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VT6306 = (int) 107;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_UNLOCK = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_BR_PAIR_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPDIF_LOCK_ON = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_FREQUENCY_48000 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_PARITY_DEFAULT = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_INIC_COMMUNICATION = (int) 11;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_ECU_W4MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_2500 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_FAILED_WRONG_TARGET = (int) 0x00000008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CONNECTION_CLOSED = (int) 211;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CHANNEL_AB = (short) (0x01 | 0x02);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_SPY_FRAMEFLAG_FRAME_CRC_ERROR = (byte) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_RX_OK = (short) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_FAMILY_PCIE = (int) (2 << 24);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXTS = (int) 0xD5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_TYPE_VN8800 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_APPLCONFIG_MAX_CHANNELS = (int) 256;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_CONNECTOR_DSUB = (short) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_ERRMSG = (short) 0x0015;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SPECIAL_NODE_MASK_CHANGED = (int) 0x00003FFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_NA_CHANGED = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CLOCK_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_NETWORK_TX_ERROR_INVALID_CRC = (int) 0x00000020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_RX_BUFFER_TYPE_ASYNC = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_LATENCY_LOW = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_DEVICEMODE_BYPASS = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CANNOT_OPEN_DRIVER = (int) 201;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEMANDED_START = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_NORMAL = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_DEACTIVATE = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_CC_ERROR = (byte) 0x06;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_COLDSTART_LISTEN = (int) 0x21;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_MESSAGE = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_IPv4 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_IPv6 = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_BYPASSTIMING = (int) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_MAX_NAME_LENGTH = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1041A_OPTO = (int) 0x012F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_LIN_SLAVE = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_OUTPUT_MODE_NORMAL = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_A429_EV_TAG_RX_OK = (short) 0x0608;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_BIT_ERROR = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_ANALOG_TRIGGER = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_LEVEL = (int) 142;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_FREQUENCY_48000 = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_SET_CONFIG_DELAYED = (int) 0x1105;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_TXMSG_FLAG_HIGHPRIO = (int) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_MOD_IEEE_RGMII_AR8031 = (int) 0x0301;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_PARAMS_CANOPMODE_CANFD_NO_ISO = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_MISSING_OFFSET_CORRECTION = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_CL_MIN = (int) 0x000C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX = (short) 0x0500;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bPCTC = (int) 0xE2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_TX_MSG_CTRL_CYCLIC = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM54810_FIX = (int) 0x0230;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_CONNECTOR_RJ45 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_STREAM_TX_UNDERFLOW = (short) 0x022B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_EVA_10 = (int) 0x000f;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_EVA_11 = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SPDIF_ERR_HW_COMMUNICATION = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1054_MAG = (int) 0x0033;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_RESERVED_NOT_ZERO = (int) 157;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_TIMER = (short) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TS_DATA_SIZE = (int) 12;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CTRL_RETRY_TIME_MIN = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MAX_HWTYPE = (int) 121;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bPCTS = (int) 0xE3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_SUPERVISOR_LOCKSTATUS = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_FRAME_BYPASSED = (short) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_DUPLEX_FULL = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_OUTPUT_MODE_SILENT = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_UNEXP_NET_ERR = (int) 145;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_ADD_TEMPORARY = (int) 0x1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_COLDSTART_JOIN = (int) 0x25;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_WAKEUP_DETECT = (int) 0x13;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_MOST150_DEVICEMODE_MASTER = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_XRTY_CHANGED = (int) 0x0200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_EVA_00 = (int) 0x000d;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_LIN_CALC_CHECKSUM_ENHANCED = (short) 0x200;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_TYPE_ETHERNET_PACKET = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_EVA_01 = (int) 0x000e;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_6259_MAG = (int) 0x0023;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MODE_ACTIVATE = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_FRAME_TRANSMITTED = (short) 0x8000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_CONNECTOR_RJ45 = (short) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_GET_SOURCE = (int) 0x05;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_REQ_TXACK = (short) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_SEQ_DURATION_MAX = (int) 655350;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_USB_UNKNOWN = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_SYNC_MUTE_STATUS = (short) 0x0213;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHIPSTAT_ERROR_ACTIVE = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_TX_REQUEST = (short) 0x0403;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_SHUTDOWN_FLAG = (int) 0x00000040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_STUFF_ERROR = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_TABA = (int) 0x00040000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_A429_HOLT8596_FIX = (int) 0x0143;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_DEVICE_SPDIF_OUT = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_TABB = (int) 0x04000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_CMACTLICENSE_SUPPORT = (int) 0x40000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UNCONFIGURE_ECU = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_DAIO_1021_FIX_WITH_5V = (int) 0x0292;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SHUTDOWN_FLAG_SET = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_NORMAL = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_OS8104_SPDIF_LOCK_ERROR = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D1 = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_INVALID_RX_LENGTH = (int) 0x00008000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_MEASUREMENT = (short) 0x0562;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D2 = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN5620A = (int) 121;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_1AE10MLAN8670_LAN8670 = (int) 0x0405;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D0 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_RX_BUFFER_BLOCK_MODE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_ADD_PERMANENT = (int) 0x0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D5 = (int) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D6 = (int) 0x40;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_QUEUE_OVERFLOW = (int) 0x100;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D3 = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ETHERNET_SPY = (short) 0x021E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_STATE_UNKNOWN = (int) 0xFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_COLLISION_HEADER = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D4 = (int) 0x10;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_EVENT_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_AVAILABLE = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_UART_PARITY_SPACE = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_BRS = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_CONFIGRESULT = (short) 0x0530;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ERROR_ETH_TX_ACK_HANDLE = (int) 0x00000002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_BCM89890 = (int) 0x0402;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NOTIFY_ALREADY_ACTIVE = (int) 131;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_1000BASE_T1 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_HWSYNC_KEYPAD = (String) "HWSYNC_KEYPAD";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_KLINE = (String) "K-Line";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_EVENT_MAX_DATA_SIZE = (int) 1024;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_NOT_ENOUGH_FREE_BW = (int) 0x00000005;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_RECEIVED_WUP = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1611 = (int) 63;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_STATUS_VALID_CLUSTER_CFG = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NO_LICENSE = (int) 14;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_CAN = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXTAH = (int) 0xC2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_TX = (int) 0x0111;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_PDU_OFFSET_REPET_INVALID = (int) 0x0106;
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 0
     */
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_ALLOC_TABLE = (int) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXTAL = (int) 0xC3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ECL_GLITCH_FILTER = (short) 0x022E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_GLITCH_FILTER_MAX = (int) 50000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_CODING_RZ = (int) 5;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1041A_OPTO = (int) 0x0021;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_DUPLEX_HALF = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_RX_OS8104_SIZE = (int) 28;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_TX_CONFLICT = (short) 0x1000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_COLDSTART_COLLISION_RESOLUTION = (int) 0x22;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VN1610 = (int) 55;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_BCM89883 = (int) 0x0401;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MPR_CHANGED = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_INVALID_HANDLE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_STATUS_PRESENT = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int CANFD_CONFOPT_NO_ISO = (int) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_INITIALIZE_SCHEDULE = (int) 0x29;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_MASK_DIGITAL_D7 = (int) 0x80;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_DUE_TO_CFG_NOT_OK = (int) 0x00000007;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_TX_OK = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_ERRC_OVLD_ERROR = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_J1708 = (int) (0x00000100 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_NPR_SPY_CHANGED = (int) 0x00000400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BYPASS_STRESS_TIME_MAX = (int) 65535;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_ERROR_CLOCK_CORR_FAILURE = (byte) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_EMPTY_SLOT = (short) 0x2000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_ACTIVE_CAP_LIN = (int) (0x00000002 << 16);
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_EVENTSOURCES = (int) 0x0103;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CC_COLD_B = (short) 0x08;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERROR = (int) 255;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_CHANNEL_MASK = (int) 204;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_CC_COLD_A = (short) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_BUSLOAD_COUNTER_TYPE_2_BYTE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_STATUS_INTEGRATION_LISTEN = (int) 0x27;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_A429_EV_TAG_TX_OK = (short) 0x0600;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NOTIFY_REASON_CHANNEL_DEACTIVATION = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_VN2640 = (short) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_MAX_DATA_LEN = (int) 64;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_PENDING = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short LIN_SLEEP = (short) 0x0019;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_MDI_STRAIGHT = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_IPCLIENT = (int) 69;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SOURCE_SYNC_RC_OVER = (int) 0x0040;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_PACK_NO_RESPONSE = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNC_RX_OVERFLOW = (int) 0x011e;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ERROR_EV_SIZE_4 = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_CHANNEL_CFG_MODE_COMBINED = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_FLAG_DELETE_CYCLIC = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SYNC_MUTE_STATUS = (int) 0x0120;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bSDC2 = (int) 0x8C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bRCD0 = (int) 0xA3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bSDC3 = (int) 0x8D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NET_CFG_DUPLICATE_MP_NAME = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_OUTPUT_MODE_SJA_1000_SILENT = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_10000 = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_GENLIGHTERROR = (int) 0x0121;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_CMD_TIMEOUT = (int) 121;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_FLAG_TAKE_ADDRNOT = (int) 0x80000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANAC2PCI = (int) 6;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_TX_OK = (short) 0x0404;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_BR_PAIR_DONT_CARE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INSUFFICIENT_BUFFER = (int) 135;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_PAYLOAD_INCREMENT_NONE = (byte) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_TRANSMIT_MSG = (short) 0x000A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMINGMODE = (int) 0x0108;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_FREQUENCY = (int) 0x0109;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_WAKEUP = (int) 0x2000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_TWIN_CAN_1041A_MAG = (int) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_TRANSCEIVER_MODE_STANDBY = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_NOT_IN_NETON = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_OFF_CL_ALREADY_USED = (int) 0x0000000A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bXSR2 = (int) 0x97;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1051_CAP_FIX = (int) 0x013C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_LAN8670_V2_2CH = (int) 0x0483;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_CANCARDXLE = (int) 43;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_MOST150_DEVICEMODE_SLAVE = (byte) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_TRANSCEIVER_MODE_RECEIVE_ONLY = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STARTUP_NO_ERRORINFO = (int) 0xFFFFFFFFL;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_VN2600 = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_EDA = (int) 0x00010000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_CC_EDB = (int) 0x01000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_CL_MISSING = (int) 9;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_AE_MOD_BR_RTL9010AA = (int) 0x0407;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_SIZE_HEADER = (short) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_BUS_COMPATIBLE_KLINE = (int) 0x00000800;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_REGISTERBUNCH1 = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_CONTENT_ERROR = (short) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_REGISTERBUNCH2 = (int) 0x0008;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_LIN_FLAG_USE_ID_AS_WAKEUPID = (byte) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STATESEL_REGISTERBUNCH3 = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_SPEED_AUTO_100 = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_DATA_GET = (int) 0x8000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_ECU_W4MAX = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_SPDIF_OUT = (int) 0x00000003;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_FULL = (int) 0x00000064;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_GEN_BYPASS_STRESS = (short) 0x022C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_PORT_TYPE_MASK_ANALOG = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_LOCK_STRESS = (int) 0x00002000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_GENLOCKERROR = (int) 0x0122;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_NET_ETH_SWITCH_IS_ONLINE = (int) 0x110C;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_ECL_SEQUENCE = (int) 0x00800000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_TX_ERROR_INVALID_LENGTH = (int) 7;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ECL_SEQ_DURATION_MIN = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_NET_OFF = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1050 = (int) 0x000E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_EVT_ID_DIGITAL = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_UNKNOWN_FLAG = (int) 0x0206;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_EVENT_HEADER_SIZE = (int) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_ERR_NO_ERROR = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SHUTDOWN_NO_ERROR = (int) 0x00000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_SPEED_1000 = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SPY_RX_STATUS_FRAME_LENGTH_ERROR = (int) 0x20;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_ETH_RESET_FAILED = (int) 0x1104;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_PAYLOAD_INCREMENT_32BIT = (byte) 32;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_ERROR_MISSING_RATE_CORRECTION = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_STATUS_PHY_10BASE_T1S = (int) 8;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_STD = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_TXMSG_FLAG_EDL = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_TX_DATA = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CAN_RXMSG_FLAG_ARB_LOST = (int) 0x0400;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_BYTE_PARITY_ERROR_MASK = (int) 0x2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_LINE_OUT = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MUTE = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_SYMBOL_WINDOW = (short) 0x0086;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_MDI_CROSSOVER = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CONNECTION_INFO_USB_FULLSPEED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_SWC_OPTO = (int) 0x0117;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ECL_TERMINATION_CHANGED = (short) 0x0223;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VIRTUAL = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_NO_ERROR = (int) 0x00;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INTERNAL_ERROR = (int) 144;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1041 = (int) 0x0010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_WAKEUP = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_VALID_DATALENANNOUNCED = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_FR_SPY_FRAMEFLAG_STATIC_FRAME = (byte) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHIPSTAT_ERROR_PASSIVE = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_NA = (int) 0x0000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short RECEIVE_DAIO_DATA = (short) 0x0020;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX_SIMULATION = (short) 0x0550;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1051_CAP = (int) 0x013F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_STREAM_NOT_CONNECTED = (int) 215;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_FDFLAG_MODE20 = (int) 0x0203;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX_ERROR = (short) 0x0501;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_DATAFRAME_FLAGS_USE_SOURCE_MAC = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ETH_MODE_PHY_IEEE_802_3 = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_DAIO_TRIGGER_LEVEL_NONE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_EV_RX_ERROR_FRAME_FORMAT = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FPGA_CORE_TYPE_LIN = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_WAKEUP_RESERVED = (int) 0xFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMETX_ERROR_SIMULATION = (short) 0x0553;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_7269_CAP_FIX = (int) 0x013E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_LIN_6259_OPTO = (int) 0x0019;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_RXLIGHT_LOCKSTATUS = (short) 0x020F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_ETH_BCM54811S_FIX = (int) 0x0236;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bNAL = (int) 0x8B;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_ASYNC_SPY = (short) 0x020A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bNAH = (int) 0x8A;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_STREAM_LATENCY_MEDIUM = (int) 2;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_TRXMODE_HIGHSPEED = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_BYPASS_QUEUE_OVERFLOW = (short) 0x8000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1050_MAG = (int) 0x0037;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMINGMODE_SPDIF = (int) 0x012b;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_REMOTE_DEVICE_CONNECTED = (int) 0x00000004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bCM4 = (int) 0x93;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_TYPE_QUEUE_OVERFLOW = (int) 0x00000010;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_LIGHT_FORCE_ON = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_NORMAL = (int) 0x0009;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_RX_FRAME = (short) 0x0081;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_LOCKSTATUS = (int) 0x0119;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_KLINE_ERR_RXTX_UA = (int) 0x04;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bCM2 = (int) 0x8E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_TIMING_MASTER_SPDIF_MASTER = (int) 4;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_STREAM_STATE_ERROR_NOT_ENOUGH_BW = (int) 1;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_TWIN_CAN_1041AV2_MAG = (int) 0x0082;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_IPCL8800 = (int) 96;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_ETH_EVENT_TAG_FRAMERX_ERROR_MEASUREMENT = (short) 0x0561;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_INIC_NISTATE_CHANGED = (int) 0x00002000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final byte XL_MOST150_DEVICEMODE_STATIC_MASTER = (byte) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_bNDR = (int) 0x8F;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_ERR_INVALID_USER_BUFFER = (int) 146;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_FR_1080_MAG = (int) 0x0202;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_CTRL_RX_SPY = (int) 0x010d;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_SOURCE_BUSLOAD_ASYNC = (int) 0x00008000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_IPSRV8800 = (int) 97;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_GA_CHANGED = (int) 0x0002;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final String XL_BUS_NAME_STREAM = (String) "Stream";
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_STARTUP = (short) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_REGISTER_BITS = (int) 0x010b;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_FR_FRAMEFLAG_NULLFRAME = (short) 0x0004;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_BUSLOAD_COUNTER_TYPE_3_BYTE = (int) 0x03;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VT6104B = (int) 88;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ASYNC_NEXT_STARTS_TO_EARLY = (int) 0x0D;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_HWTYPE_VT6104A = (int) 108;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_CYCLE_MAX = (int) 0x3FFFFFFF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_NOTIFY_REASON_PORT_CLOSED = (int) 3;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHANNEL_FLAG_CANFD_BOSCH_SUPPORT = (int) 0x20000000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_ASYNC_RETRY_PARAMS_CHANGED = (int) 0x00000180;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_MOST150_GEN_LIGHT_ERROR = (short) 0x0215;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MODE_COLDSTART_LEADING = (int) 0x02;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_CACK_CRC_ERROR = (int) 0x00000001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_CHIPSTAT_BUSOFF = (int) 0x01;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_MODE_DEACTIVATE = (int) 0;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_LIN_6258_OPTO = (int) 0x0129;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_LINEMODE_TWO_LINE = (int) 0x0001;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_COMMAND_FAILED = (int) 0x4000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_SBC_CHANGED = (int) 0x0080;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST150_DEVICE_MODE_CL_NOT_ALLOCATED = (int) 0x000000FF;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_PB_CAN_1041_OPTO = (int) 0x0121;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_TRANSCEIVER_TYPE_CAN_1057B_FIX = (int) 0x014E;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_A429_MSG_BITRATE_SLOW_MAX = (int) 16000;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_MOST_ALLBYPASS = (int) 0x0107;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final int XL_FR_MAX_DATA_LENGTH = (int) 254;
    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public static final short XL_CAN_EV_TAG_CHIP_STATE = (short) 0x0409;

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlOpenDriver()</code><br>
     * <i>native declaration : vxlapi.h:15</i>
     */
    short xlOpenDriver();

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCloseDriver()</code><br>
     * <i>native declaration : vxlapi.h:29</i>
     */
    short xlCloseDriver();

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetApplConfig(char*, unsigned int, unsigned int*, unsigned int*, unsigned int*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:49</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetApplConfig(ByteBuffer, int, IntBuffer, IntBuffer, IntBuffer, int)} and {@link #xlGetApplConfig(com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, int)} instead
     */
    @Deprecated
    short xlGetApplConfig(Pointer appName, int appChannel, IntByReference pHwType, IntByReference pHwIndex, IntByReference pHwChannel, int busType);
    /**
     * define<br>
     * Conversion Error : null<br>
     * SKIPPED:<br>
     * <i>native declaration : vxlapi.h</i><br>
     * << 10
     */

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetApplConfig(char*, unsigned int, unsigned int*, unsigned int*, unsigned int*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:49</i>
     */
    short xlGetApplConfig(ByteBuffer appName, int appChannel, IntBuffer pHwType, IntBuffer pHwIndex, IntBuffer pHwChannel, int busType);

    ;

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetApplConfig(char*, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:58</i><br>
     *
     * @deprecated use the safer methods {@link #xlSetApplConfig(ByteBuffer, int, int, int, int, int)} and {@link #xlSetApplConfig(com.sun.jna.Pointer, int, int, int, int, int)} instead
     */
    @Deprecated
    short xlSetApplConfig(Pointer appName, int appChannel, int hwType, int hwIndex, int hwChannel, int busType);

    ;

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetApplConfig(char*, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:58</i>
     */
    short xlSetApplConfig(ByteBuffer appName, int appChannel, int hwType, int hwIndex, int hwChannel, int busType);

    ;

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetDriverConfig(XLdriverConfig*)</code><br>
     * <i>native declaration : vxlapi.h:76</i>
     */
    short xlGetDriverConfig(s_xl_driver_config pDriverConfig);

    ;

    /**
     * xlCreateDriverConfig()
     * <br>
     * \brief Function to retrieve requested version of the driver configuration interface.
     * <br>
     * <br>
     * \param version          [IN] Requested version of the interface.
     * <br>
     * \param pConfigInterface [OUT] The context handle and the function pointer table of the requested version.
     * <br>
     * \return XLstatus     XL_SUCCESS on success<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCreateDriverConfig(XLIdriverConfigVersion, XLIDriverConfig*)</code><br>
     * <i>native declaration : vxlapi.h:88</i>
     */
    short xlCreateDriverConfig(int version, XLIDriverConfig pConfigInterface);

    ;

    /**
     * xlDestroyDriverConfig()
     * <br>
     * \brief Function to release driver configuration context.
     * <br>
     * <br>
     * \param configHandle     [IN] The handle to reference the context.
     * <br>
     * \return XLstatus     XL_SUCCESS on success<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDestroyDriverConfig(XLdrvConfigHandle)</code><br>
     * <i>native declaration : vxlapi.h:98</i><br>
     *
     * @deprecated use the safer methods {@link #xlDestroyDriverConfig(Vxlapi64DllLibrary.XLdrvConfigHandle)} and {@link #xlDestroyDriverConfig(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlDestroyDriverConfig(Pointer configHandle);

    ;

    /**
     * xlDestroyDriverConfig()
     * <br>
     * \brief Function to release driver configuration context.
     * <br>
     * <br>
     * \param configHandle     [IN] The handle to reference the context.
     * <br>
     * \return XLstatus     XL_SUCCESS on success<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDestroyDriverConfig(XLdrvConfigHandle)</code><br>
     * <i>native declaration : vxlapi.h:98</i>
     */
    short xlDestroyDriverConfig(XLdrvConfigHandle configHandle);

    ;

    /**
     * \brief Get the channel index for a channel of a certain hardware.
     * <br>
     * \param  hwType                  [IN] hwType of the device or -1 for don't care
     * <br>
     * \param  hwIndex                 [IN] hwIndex of the device or -1 for don't care
     * <br>
     * \param  hwChannel               [IN] index of the channel on the device or -1 for don't care
     * <br>
     * \return index of the selected channel or -1 if not found.<br>
     * Original signature : <code>__attribute__((dllexport)) int xlGetChannelIndex(int, int, int)</code><br>
     * <i>native declaration : vxlapi.h:106</i>
     */
    int xlGetChannelIndex(int hwType, int hwIndex, int hwChannel);

    /**
     * \brief Get the channel mask for a channel of a certain hardware.
     * <br>
     * \param  hwType                  [IN] hwType of the device or -1 for don't care
     * <br>
     * \param  hwIndex                 [IN] hwIndex of the device or -1 for don't care
     * <br>
     * \param  hwChannel               [IN] index of the channel on the device or -1 for don't care
     * <br>
     * \return mask of the selected channel or 0 if not found.<br>
     * Original signature : <code>__attribute__((dllexport)) XLaccess xlGetChannelMask(int, int, int)</code><br>
     * <i>native declaration : vxlapi.h:114</i>
     */
    long xlGetChannelMask(int hwType, int hwIndex, int hwChannel);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlOpenPort(XLportHandle*, char*, XLaccess, XLaccess*, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:127</i><br>
     *
     * @deprecated use the safer methods {@link #xlOpenPort(com.sun.jna.ptr.NativeLongByReference, ByteBuffer, long, LongBuffer, int, int, int)} and {@link #xlOpenPort(com.sun.jna.ptr.NativeLongByReference, com.sun.jna.Pointer, long, com.sun.jna.ptr.LongByReference, int, int, int)} instead
     */
    @Deprecated
    short xlOpenPort(NativeLongByReference pPortHandle, Pointer userName, long accessMask, LongByReference pPermissionMask, int rxQueueSize, int xlInterfaceVersion, int busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlOpenPort(XLportHandle*, char*, XLaccess, XLaccess*, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:127</i>
     */
    short xlOpenPort(NativeLongByReference pPortHandle, ByteBuffer userName, long accessMask, LongBuffer pPermissionMask, int rxQueueSize, int xlInterfaceVersion, int busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCreatePort(XLportHandle*, const char*, unsigned int, unsigned int, XLuint64)</code><br>
     * <i>native declaration : vxlapi.h:139</i><br>
     *
     * @deprecated use the safer methods {@link #xlCreatePort(com.sun.jna.ptr.NativeLongByReference, String, int, int, long)} and {@link #xlCreatePort(com.sun.jna.ptr.NativeLongByReference, com.sun.jna.Pointer, int, int, long)} instead
     */
    @Deprecated
    short xlCreatePort(NativeLongByReference pPortHandle, Pointer appName, int rxQueueSize, int xlInterfaceVersion, long busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCreatePort(XLportHandle*, const char*, unsigned int, unsigned int, XLuint64)</code><br>
     * <i>native declaration : vxlapi.h:139</i>
     */
    short xlCreatePort(NativeLongByReference pPortHandle, String appName, int rxQueueSize, int xlInterfaceVersion, long busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlAddChannelToPort(XLportHandle, XLaccess, unsigned int, unsigned int*, XLuint64)</code><br>
     * <i>native declaration : vxlapi.h:151</i><br>
     *
     * @deprecated use the safer methods {@link #xlAddChannelToPort(com.sun.jna.NativeLong, long, int, IntBuffer, long)} and {@link #xlAddChannelToPort(com.sun.jna.NativeLong, long, int, com.sun.jna.ptr.IntByReference, long)} instead
     */
    @Deprecated
    short xlAddChannelToPort(NativeLong portHandle, long channelIndex, int initAccess, IntByReference permission, long busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlAddChannelToPort(XLportHandle, XLaccess, unsigned int, unsigned int*, XLuint64)</code><br>
     * <i>native declaration : vxlapi.h:151</i>
     */
    short xlAddChannelToPort(NativeLong portHandle, long channelIndex, int initAccess, IntBuffer permission, long busType);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFinalizePort(XLportHandle)</code><br>
     * <i>native declaration : vxlapi.h:161</i>
     */
    short xlFinalizePort(NativeLong portHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetTimerRate(XLportHandle, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:173</i>
     */
    short xlSetTimerRate(NativeLong portHandle, NativeLong timerRate);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetTimerRateAndChannel(XLportHandle, XLaccess*, XLulong*)</code><br>
     * <i>native declaration : vxlapi.h:200</i><br>
     *
     * @deprecated use the safer methods {@link #xlSetTimerRateAndChannel(com.sun.jna.NativeLong, LongBuffer, com.sun.jna.ptr.NativeLongByReference)} and {@link #xlSetTimerRateAndChannel(com.sun.jna.NativeLong, com.sun.jna.ptr.LongByReference, com.sun.jna.ptr.NativeLongByReference)} instead
     */
    @Deprecated
    short xlSetTimerRateAndChannel(NativeLong portHandle, LongByReference timerChannelMask, NativeLongByReference timerRate);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetTimerRateAndChannel(XLportHandle, XLaccess*, XLulong*)</code><br>
     * <i>native declaration : vxlapi.h:200</i>
     */
    short xlSetTimerRateAndChannel(NativeLong portHandle, LongBuffer timerChannelMask, NativeLongByReference timerRate);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlResetClock(XLportHandle)</code><br>
     * <i>native declaration : vxlapi.h:210</i>
     */
    short xlResetClock(NativeLong portHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetNotification(XLportHandle, XLhandle*, int)</code><br>
     * <i>native declaration : vxlapi.h:224</i><br>
     *
     * @deprecated use the safer method {@link #xlSetNotification(com.sun.jna.NativeLong, com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    short xlSetNotification(NativeLong portHandle, Pointer pHandle, int queueLevel);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetNotification(XLportHandle, XLhandle*, int)</code><br>
     * <i>native declaration : vxlapi.h:224</i>
     */
    short xlSetNotification(NativeLong portHandle, PointerByReference pHandle, int queueLevel);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetTimerBasedNotify(XLportHandle, XLhandle*)</code><br>
     * <i>native declaration : vxlapi.h:234</i><br>
     *
     * @deprecated use the safer method {@link #xlSetTimerBasedNotify(com.sun.jna.NativeLong, com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    short xlSetTimerBasedNotify(NativeLong portHandle, Pointer pHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetTimerBasedNotify(XLportHandle, XLhandle*)</code><br>
     * <i>native declaration : vxlapi.h:234</i>
     */
    short xlSetTimerBasedNotify(NativeLong portHandle, PointerByReference pHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFlushReceiveQueue(XLportHandle)</code><br>
     * <i>native declaration : vxlapi.h:242</i>
     */
    short xlFlushReceiveQueue(NativeLong portHandle);

    /**
     * ------------------------------------------------------------------------------
     * <br>
     * xlGetReceiveQueueLevel():
     * <br>
     * --------------------------------------------------------------------------------
     * <br>
     * Return the count of bytes or events in the receive queue of the given port. The unit depends
     * <br>
     * on the interface verion used when the port was opened:
     * <br>
     * - XL_INTERFACE_VERSION_V3: level contains number of events.
     * <br>
     * - XL_INTERFACE_VERSION_V4: level contains number of bytes. Event encoding and size may differ
     * <br>
     * between the fifo layout and the XLAPI interface<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetReceiveQueueLevel(XLportHandle, int*)</code><br>
     * <i>native declaration : vxlapi.h:253</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetReceiveQueueLevel(com.sun.jna.NativeLong, IntBuffer)} and {@link #xlGetReceiveQueueLevel(com.sun.jna.NativeLong, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlGetReceiveQueueLevel(NativeLong portHandle, IntByReference level);

    /**
     * ------------------------------------------------------------------------------
     * <br>
     * xlGetReceiveQueueLevel():
     * <br>
     * --------------------------------------------------------------------------------
     * <br>
     * Return the count of bytes or events in the receive queue of the given port. The unit depends
     * <br>
     * on the interface verion used when the port was opened:
     * <br>
     * - XL_INTERFACE_VERSION_V3: level contains number of events.
     * <br>
     * - XL_INTERFACE_VERSION_V4: level contains number of bytes. Event encoding and size may differ
     * <br>
     * between the fifo layout and the XLAPI interface<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetReceiveQueueLevel(XLportHandle, int*)</code><br>
     * <i>native declaration : vxlapi.h:253</i>
     */
    short xlGetReceiveQueueLevel(NativeLong portHandle, IntBuffer level);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlActivateChannel(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:262</i>
     */
    short xlActivateChannel(NativeLong portHandle, long accessMask, int busType, int flags);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlReceive(XLportHandle, unsigned int*, XLevent*)</code><br>
     * <i>native declaration : vxlapi.h:281</i><br>
     *
     * @deprecated use the safer methods {@link #xlReceive(com.sun.jna.NativeLong, IntBuffer, s_xl_event)} and {@link #xlReceive(com.sun.jna.NativeLong, com.sun.jna.ptr.IntByReference, s_xl_event)} instead
     */
    @Deprecated
    short xlReceive(NativeLong portHandle, IntByReference pEventCount, s_xl_event pEvents);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlReceive(XLportHandle, unsigned int*, XLevent*)</code><br>
     * <i>native declaration : vxlapi.h:281</i>
     */
    short xlReceive(NativeLong portHandle, IntBuffer pEventCount, s_xl_event pEvents);

    /**
     * ------------------------------------------------------------------------------
     * <br>
     * xlGetErrorString():
     * <br>
     * xlGetEventString():
     * <br>
     * xlCanGetEventString():
     * <br>
     * --------------------------------------------------------------------------------
     * <br>
     * Utility Functions<br>
     * Original signature : <code>__attribute__((dllexport)) XLstringType xlGetErrorString(XLstatus)</code><br>
     * <i>native declaration : vxlapi.h:290</i>
     */
    Pointer xlGetErrorString(short err);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstringType xlGetEventString(XLevent*)</code><br>
     * <i>native declaration : vxlapi.h:291</i>
     */
    Pointer xlGetEventString(s_xl_event pEv);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstringType xlCanGetEventString(XLcanRxEvent*)</code><br>
     * <i>native declaration : vxlapi.h:292</i>
     */
    Pointer xlCanGetEventString(XLcanRxEvent pEv);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlOemContact(XLportHandle, XLulong, XLuint64, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:299</i><br>
     *
     * @deprecated use the safer methods {@link #xlOemContact(com.sun.jna.NativeLong, com.sun.jna.NativeLong, long, LongBuffer)} and {@link #xlOemContact(com.sun.jna.NativeLong, com.sun.jna.NativeLong, long, com.sun.jna.ptr.LongByReference)} instead
     */
    @Deprecated
    short xlOemContact(NativeLong portHandle, NativeLong Channel, long context1, LongByReference context2);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlOemContact(XLportHandle, XLulong, XLuint64, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:299</i>
     */
    short xlOemContact(NativeLong portHandle, NativeLong Channel, long context1, LongBuffer context2);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetSyncTime(XLportHandle, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:308</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetSyncTime(com.sun.jna.NativeLong, LongBuffer)} and {@link #xlGetSyncTime(com.sun.jna.NativeLong, com.sun.jna.ptr.LongByReference)} instead
     */
    @Deprecated
    short xlGetSyncTime(NativeLong portHandle, LongByReference pTime);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetSyncTime(XLportHandle, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:308</i>
     */
    short xlGetSyncTime(NativeLong portHandle, LongBuffer pTime);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetChannelTime(XLportHandle, XLaccess, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:316</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetChannelTime(com.sun.jna.NativeLong, long, LongBuffer)} and {@link #xlGetChannelTime(com.sun.jna.NativeLong, long, com.sun.jna.ptr.LongByReference)} instead
     */
    @Deprecated
    short xlGetChannelTime(NativeLong portHandle, long accessMask, LongByReference pChannelTime);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetChannelTime(XLportHandle, XLaccess, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:316</i>
     */
    short xlGetChannelTime(NativeLong portHandle, long accessMask, LongBuffer pChannelTime);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGenerateSyncPulse(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:326</i>
     */
    short xlGenerateSyncPulse(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlPopupHwConfig(char*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:355</i><br>
     *
     * @deprecated use the safer methods {@link #xlPopupHwConfig(ByteBuffer, int)} and {@link #xlPopupHwConfig(com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    short xlPopupHwConfig(Pointer callSign, int waitForFinish);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlPopupHwConfig(char*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:355</i>
     */
    short xlPopupHwConfig(ByteBuffer callSign, int waitForFinish);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDeactivateChannel(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:365</i>
     */
    short xlDeactivateChannel(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlClosePort(XLportHandle)</code><br>
     * <i>native declaration : vxlapi.h:373</i>
     */
    short xlClosePort(NativeLong portHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanFlushTransmitQueue(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:385</i>
     */
    short xlCanFlushTransmitQueue(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelOutput(XLportHandle, XLaccess, int)</code><br>
     * <i>native declaration : vxlapi.h:395</i>
     */
    short xlCanSetChannelOutput(NativeLong portHandle, long accessMask, int mode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelMode(XLportHandle, XLaccess, int, int)</code><br>
     * <i>native declaration : vxlapi.h:406</i>
     */
    short xlCanSetChannelMode(NativeLong portHandle, long accessMask, int tx, int txrq);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetReceiveMode(XLportHandle, unsigned char, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:413</i>
     */
    short xlCanSetReceiveMode(NativeLong Port, byte ErrorFrame, byte ChipState);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelTransceiver(XLportHandle, XLaccess, int, int, int)</code><br>
     * <i>native declaration : vxlapi.h:430</i>
     */
    short xlCanSetChannelTransceiver(NativeLong portHandle, long accessMask, int type, int lineMode, int resNet);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelParams(XLportHandle, XLaccess, XLchipParams*)</code><br>
     * <i>native declaration : vxlapi.h:443</i>
     */
    short xlCanSetChannelParams(NativeLong portHandle, long accessMask, XLchipParams pChipParams);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelParamsC200(XLportHandle, XLaccess, unsigned char, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:446</i>
     */
    short xlCanSetChannelParamsC200(NativeLong portHandle, long accessMask, byte btr0, byte btr1);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelBitrate(XLportHandle, XLaccess, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:449</i>
     */
    short xlCanSetChannelBitrate(NativeLong portHandle, long accessMask, NativeLong bitrate);

    /**
     * configures CAN-FD<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanFdSetConfiguration(XLportHandle, XLaccess, XLcanFdConf*)</code><br>
     * <i>native declaration : vxlapi.h:455</i>
     */
    short xlCanFdSetConfiguration(NativeLong portHandle, long accessMask, XLcanFdConf pCanFdConf);

    /**
     * receives a CAN/CAN-FD event from the applications receive queue<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanReceive(XLportHandle, XLcanRxEvent*)</code><br>
     * <i>native declaration : vxlapi.h:463</i>
     */
    short xlCanReceive(NativeLong portHandle, XLcanRxEvent pXlCanRxEvt);

    /**
     * transmits a number of CAN / CAN-FD events<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanTransmitEx(XLportHandle, XLaccess, unsigned int, unsigned int*, XLcanTxEvent*)</code><br>
     * <i>native declaration : vxlapi.h:470</i><br>
     *
     * @deprecated use the safer methods {@link #xlCanTransmitEx(com.sun.jna.NativeLong, long, int, IntBuffer, XLcanTxEvent)} and {@link #xlCanTransmitEx(com.sun.jna.NativeLong, long, int, com.sun.jna.ptr.IntByReference, XLcanTxEvent)} instead
     */
    @Deprecated
    short xlCanTransmitEx(NativeLong portHandle, long accessMask, int msgCnt, IntByReference pMsgCntSent, XLcanTxEvent pXlCanTxEvt);

    /**
     * transmits a number of CAN / CAN-FD events<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanTransmitEx(XLportHandle, XLaccess, unsigned int, unsigned int*, XLcanTxEvent*)</code><br>
     * <i>native declaration : vxlapi.h:470</i>
     */
    short xlCanTransmitEx(NativeLong portHandle, long accessMask, int msgCnt, IntBuffer pMsgCntSent, XLcanTxEvent pXlCanTxEvt);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanSetChannelAcceptance(XLportHandle, XLaccess, XLulong, XLulong, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:483</i>
     */
    short xlCanSetChannelAcceptance(NativeLong portHandle, long accessMask, NativeLong code, NativeLong mask, int idRange);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanAddAcceptanceRange(XLportHandle, XLaccess, XLulong, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:493</i>
     */
    short xlCanAddAcceptanceRange(NativeLong portHandle, long accessMask, NativeLong first_id, NativeLong last_id);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanRemoveAcceptanceRange(XLportHandle, XLaccess, XLulong, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:495</i>
     */
    short xlCanRemoveAcceptanceRange(NativeLong portHandle, long accessMask, NativeLong first_id, NativeLong last_id);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanResetAcceptance(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:497</i>
     */
    short xlCanResetAcceptance(NativeLong portHandle, long accessMask, int idRange);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanRequestChipState(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:506</i>
     */
    short xlCanRequestChipState(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanTransmit(XLportHandle, XLaccess, unsigned int*, void*)</code><br>
     * <i>native declaration : vxlapi.h:520</i><br>
     *
     * @deprecated use the safer methods {@link #xlCanTransmit(com.sun.jna.NativeLong, long, IntBuffer, com.sun.jna.Pointer)} and {@link #xlCanTransmit(com.sun.jna.NativeLong, long, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlCanTransmit(NativeLong portHandle, long accessMask, IntByReference pEventCount, Pointer pEvents);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCanTransmit(XLportHandle, XLaccess, unsigned int*, void*)</code><br>
     * <i>native declaration : vxlapi.h:520</i>
     */
    short xlCanTransmit(NativeLong portHandle, long accessMask, IntBuffer pEventCount, Pointer pEvents);

    /**
     * ------------------------------------------------------------------------------
     * <br>
     * xlSetGlobalTimeSync():
     * <br>
     * --------------------------------------------------------------------------------
     * <br>
     * To query and change the global time sync setting<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlSetGlobalTimeSync(XLulong, XLulong*)</code><br>
     * <i>native declaration : vxlapi.h:528</i>
     */
    short xlSetGlobalTimeSync(NativeLong newValue, NativeLongByReference previousValue);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlCheckLicense(XLportHandle, XLaccess, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:539</i>
     */
    short xlCheckLicense(NativeLong portHandle, long accessMask, NativeLong protectionCode);

    /**
     * xlGetLicenseInfo()
     * <br>
     * \brief Function to get available licenses from Vector devices.
     * <br>
     * This function returns the available licenses in an array of XLlicenseInfo structures. This array contains all available licenses on
     * <br>
     * the queried channels. The position inside the array is defined by the license itself, e.g. the license for
     * <br>
     * the Advanced-Flexray-Library is always at the same array index.
     * <br>
     * \param channelMask      [IN] : Channelmask for which to query the available licenses
     * <br>
     * \param *pLicInfoArray   [OUT]: Array with license overview
     * <br>
     * \param licInfoArraySize [IN] : Size of array pointed to with 'pLicInfo' (number of array entries)
     * <br>
     * \return XLstatus            General status information is returned.
     * <br>
     * XL_SUCCESS if no error occurred.
     * <br>
     * XL_ERR_NO_RESOURCES if the given array size is too small to copy all available licenses into it.
     * <br>
     * XL_ERROR if general error occurred.<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetLicenseInfo(XLaccess, XLlicenseInfo*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:555</i>
     */
    short xlGetLicenseInfo(long channelMask, s_xl_license_info pLicInfoArray, int licInfoArraySize);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetChannelParams(XLportHandle, XLaccess, XLlinStatPar)</code><br>
     * <i>native declaration : vxlapi.h:561</i>
     */
    short xlLinSetChannelParams(NativeLong portHandle, long accessMask, XLlinStatPar.ByValue vStatPar);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetDLC(XLportHandle, XLaccess, unsigned char[64])</code><br>
     * <i>native declaration : vxlapi.h:562</i><br>
     *
     * @deprecated use the safer methods {@link #xlLinSetDLC(com.sun.jna.NativeLong, long, ByteBuffer)} and {@link #xlLinSetDLC(com.sun.jna.NativeLong, long, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlLinSetDLC(NativeLong portHandle, long accessMask, Pointer dlc);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetDLC(XLportHandle, XLaccess, unsigned char[64])</code><br>
     * <i>native declaration : vxlapi.h:562</i>
     */
    short xlLinSetDLC(NativeLong portHandle, long accessMask, ByteBuffer dlc);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetSlave(XLportHandle, XLaccess, unsigned char, unsigned char[8], unsigned char, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:563</i><br>
     *
     * @deprecated use the safer methods {@link #xlLinSetSlave(com.sun.jna.NativeLong, long, byte, ByteBuffer, byte, short)} and {@link #xlLinSetSlave(com.sun.jna.NativeLong, long, byte, com.sun.jna.Pointer, byte, short)} instead
     */
    @Deprecated
    short xlLinSetSlave(NativeLong portHandle, long accessMask, byte linId, Pointer data, byte dlc, short checksum);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetSlave(XLportHandle, XLaccess, unsigned char, unsigned char[8], unsigned char, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:563</i>
     */
    short xlLinSetSlave(NativeLong portHandle, long accessMask, byte linId, ByteBuffer data, byte dlc, short checksum);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSendRequest(XLportHandle, XLaccess, unsigned char, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:566</i>
     */
    short xlLinSendRequest(NativeLong portHandle, long accessMask, byte linId, int flags);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetSleepMode(XLportHandle, XLaccess, unsigned int, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:568</i>
     */
    short xlLinSetSleepMode(NativeLong portHandle, long accessMask, int flags, byte linId);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinWakeUp(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:570</i>
     */
    short xlLinWakeUp(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetChecksum(XLportHandle, XLaccess, unsigned char[60])</code><br>
     * <i>native declaration : vxlapi.h:571</i><br>
     *
     * @deprecated use the safer methods {@link #xlLinSetChecksum(com.sun.jna.NativeLong, long, ByteBuffer)} and {@link #xlLinSetChecksum(com.sun.jna.NativeLong, long, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlLinSetChecksum(NativeLong portHandle, long accessMask, Pointer checksum);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSetChecksum(XLportHandle, XLaccess, unsigned char[60])</code><br>
     * <i>native declaration : vxlapi.h:571</i>
     */
    short xlLinSetChecksum(NativeLong portHandle, long accessMask, ByteBuffer checksum);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlLinSwitchSlave(XLportHandle, XLaccess, unsigned char, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:572</i>
     */
    short xlLinSwitchSlave(NativeLong portHandle, long accessMask, byte linID, byte mode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetPWMOutput(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:579</i>
     */
    short xlDAIOSetPWMOutput(NativeLong portHandle, long accessMask, int frequency, int value);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetDigitalOutput(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:581</i>
     */
    short xlDAIOSetDigitalOutput(NativeLong portHandle, long accessMask, int outputMask, int valuePattern);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetAnalogOutput(XLportHandle, XLaccess, unsigned int, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:583</i>
     */
    short xlDAIOSetAnalogOutput(NativeLong portHandle, long accessMask, int analogLine1, int analogLine2, int analogLine3, int analogLine4);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIORequestMeasurement(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:586</i>
     */
    short xlDAIORequestMeasurement(NativeLong portHandle, long accessMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetDigitalParameters(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:587</i>
     */
    short xlDAIOSetDigitalParameters(NativeLong portHandle, long accessMask, int inputMask, int outputMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetAnalogParameters(XLportHandle, XLaccess, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:589</i>
     */
    short xlDAIOSetAnalogParameters(NativeLong portHandle, long accessMask, int inputMask, int outputMask, int highRangeMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetAnalogTrigger(XLportHandle, XLaccess, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:592</i>
     */
    short xlDAIOSetAnalogTrigger(NativeLong portHandle, long accessMask, int triggerMask, int triggerLevel, int triggerEventMode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetMeasurementFrequency(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:595</i>
     */
    short xlDAIOSetMeasurementFrequency(NativeLong portHandle, long accessMask, int measurementInterval);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlDAIOSetDigitalTrigger(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:597</i>
     */
    short xlDAIOSetDigitalTrigger(NativeLong portHandle, long accessMask, int triggerMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineTransmit(XLportHandle, XLaccess, unsigned int, unsigned char*)</code><br>
     * <i>native declaration : vxlapi.h:603</i><br>
     *
     * @deprecated use the safer methods {@link #xlKlineTransmit(com.sun.jna.NativeLong, long, int, ByteBuffer)} and {@link #xlKlineTransmit(com.sun.jna.NativeLong, long, int, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlKlineTransmit(NativeLong portHandle, long accessMask, int length, Pointer data);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineTransmit(XLportHandle, XLaccess, unsigned int, unsigned char*)</code><br>
     * <i>native declaration : vxlapi.h:603</i>
     */
    short xlKlineTransmit(NativeLong portHandle, long accessMask, int length, ByteBuffer data);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSetUartParams(XLportHandle, XLaccess, XLklineUartParameter*)</code><br>
     * <i>native declaration : vxlapi.h:605</i>
     */
    short xlKlineSetUartParams(NativeLong portHandle, long accessMask, s_xl_kline_uart_params pxlKlineUartParams);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSwitchHighspeedMode(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:607</i>
     */
    short xlKlineSwitchHighspeedMode(NativeLong portHandle, long accessMask, int trxMode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSwitchTesterResistor(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:609</i>
     */
    short xlKlineSwitchTesterResistor(NativeLong portHandle, long accessMask, int testerR);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSetBaudrate(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:611</i>
     */
    short xlKlineSetBaudrate(NativeLong portHandle, long accessMask, int baudrate);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineFastInitTester(XLportHandle, XLaccess, unsigned int, unsigned char*, XLklineInitTester*)</code><br>
     * <i>native declaration : vxlapi.h:613</i><br>
     *
     * @deprecated use the safer methods {@link #xlKlineFastInitTester(com.sun.jna.NativeLong, long, int, ByteBuffer, s_xl_kline_init_tester)} and {@link #xlKlineFastInitTester(com.sun.jna.NativeLong, long, int, com.sun.jna.Pointer, s_xl_kline_init_tester)} instead
     */
    @Deprecated
    short xlKlineFastInitTester(NativeLong portHandle, long accessMask, int length, Pointer data, s_xl_kline_init_tester pxlKlineInitTester);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineFastInitTester(XLportHandle, XLaccess, unsigned int, unsigned char*, XLklineInitTester*)</code><br>
     * <i>native declaration : vxlapi.h:613</i>
     */
    short xlKlineFastInitTester(NativeLong portHandle, long accessMask, int length, ByteBuffer data, s_xl_kline_init_tester pxlKlineInitTester);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineInit5BdTester(XLportHandle, XLaccess, XLkline5BdTester*)</code><br>
     * <i>native declaration : vxlapi.h:616</i>
     */
    short xlKlineInit5BdTester(NativeLong portHandle, long accessMask, s_xl_kline_init_5BdTester pxlKline5BdTester);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineInit5BdEcu(XLportHandle, XLaccess, XLkline5BdEcu*)</code><br>
     * <i>native declaration : vxlapi.h:618</i>
     */
    short xlKlineInit5BdEcu(NativeLong portHandle, long accessMask, s_xl_kline_init_5BdEcu pxlKline5BdEcu);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSetCommunicationTimingTester(XLportHandle, XLaccess, XLklineSetComTester*)</code><br>
     * <i>native declaration : vxlapi.h:620</i>
     */
    short xlKlineSetCommunicationTimingTester(NativeLong portHandle, long accessMask, s_xl_kline_set_com_tester pxlKlineSetComTester);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlKlineSetCommunicationTimingEcu(XLportHandle, XLaccess, XLklineSetComEcu*)</code><br>
     * <i>native declaration : vxlapi.h:623</i>
     */
    short xlKlineSetCommunicationTimingEcu(NativeLong portHandle, long accessMask, s_xl_kline_set_com_ecu pxlKlineSetComEcu);

    /**
     * \brief fetching events from driver queue.
     * <br>
     * This method is used to fetch events, either bus events or acknowledgments
     * <br>
     * for commands from the driver queue. Each call delivers only one event (if an event is available). \n
     * <br>
     * It is a synchronous mode and either delivers event data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API (TODO)
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channels an API should work (TODO)
     * <br>
     * \param  pEventBuffer              [IN] This parameter must point to a buffer to which the driver can copy
     * <br>
     * the next event of the receive queue
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostReceive(XLportHandle, XLmostEvent*)</code><br>
     * <i>native declaration : vxlapi.h:677</i>
     */
    short xlMostReceive(NativeLong portHandle, s_xl_most_event pEventBuffer);

    /**
     * \brief Activates or deactivates the different event sources of VN2600.
     * <br>
     * This method is used to select which bus events should be delivered by VN2600.
     * <br>
     * Either CtrlNode, CtrlSpy, AsyncNode or AsyncSpy messages \n
     * <br>
     * ResponseEvent:                         XL_MOST_EVENTSOURCES
     * <br>
     * \param sourceMask                 [IN] each bit stands for an event source and can separately be set.
     * <br>
     * Use the definitions of the sourcemask...
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSwitchEventSources(XLportHandle, XLaccess, unsigned short, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:687</i>
     */
    short xlMostSwitchEventSources(NativeLong portHandle, long accessMask, short userHandle, short sourceMask);

    /**
     * \brief Activates or deactivates the bypass of the OS8104.
     * <br>
     * This method is used to switch the Bypass OS8104 (register TODO:) on and off \n
     * <br>
     * ResponseEvent:                         XL_MOST_ALLBYPASS
     * <br>
     * \param  bypassMode                [IN] bypass open/close
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSetAllBypass(XLportHandle, XLaccess, unsigned short, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:695</i>
     */
    short xlMostSetAllBypass(NativeLong portHandle, long accessMask, short userHandle, byte bypassMode);

    /**
     * \brief Reads out the bypass mode of the OS8104.
     * <br>
     * This method is asynchronous and requests the event used to switch the Bypass OS8104.
     * <br>
     * ResponseEvent:                         XL_MOST_ALLBYPASS
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetAllBypass(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:702</i>
     */
    short xlMostGetAllBypass(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Switches the OS8104 into slave or master mode.
     * <br>
     * This method is used to switch the OS8104 into the timing master or slave mode\n
     * <br>
     * ResponseEvent:                         XL_MOST_TIMINGMODE
     * <br>
     * \param  timingMode                [IN] MOST master/slave
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSetTimingMode(XLportHandle, XLaccess, unsigned short, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:710</i>
     */
    short xlMostSetTimingMode(NativeLong portHandle, long accessMask, short userHandle, byte timingMode);

    /**
     * \brief Triggers the event XL_MOST_TIMINGMODE.
     * <br>
     * This method is used to trigger the event XL_MOST_TIMINGMODE, which will deliver
     * <br>
     * information whether the OS8104 is configured in slave or master mode.\n
     * <br>
     * ResponseEvent:                         XL_MOST_TIMINGMODE
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetTimingMode(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:718</i>
     */
    short xlMostGetTimingMode(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Selects the MOST frequency either to 44.1 kHz or 48 kHz.
     * <br>
     * This method is used to select either 44.1 kHz or 48 kHz as
     * <br>
     * bus clock when the OS8104 of VN2600 acts as timing master \n
     * <br>
     * ResponseEvent:                         XL_MOST_FREQUENCY
     * <br>
     * \param  frequency                 [IN] 44,1kHz, 48kHz
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSetFrequency(XLportHandle, XLaccess, unsigned short, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:727</i>
     */
    short xlMostSetFrequency(NativeLong portHandle, long accessMask, short userHandle, short frequency);

    /**
     * \brief Triggers the event XL_MOST_FREQUENCY.
     * <br>
     * This method is used to trigger the event XL_MOST_FREQUENCY, which will deliver
     * <br>
     * information whether the OS8104 of VN2600 as timing master
     * <br>
     * generates 44.1 kHz or 48 kHz as bus clock.\n
     * <br>
     * ResponseEvent:                         XL_MOST_FREQUENCY
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetFrequency(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:736</i>
     */
    short xlMostGetFrequency(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Allows to write up to 16 byte register in the OS8104.
     * <br>
     * This method is used to write numbyte (up to 16) bytes into the registers of the OS8104
     * <br>
     * beginning from adr. \n
     * <br>
     * ResponseEvent:                         XL_MOST_REGISTER_BYTES
     * <br>
     * \param  adr                       [IN] address (MAP) of register to which the first byte is written
     * <br>
     * \param  numBytes                  [IN] number of successive bytes to be written to the registers
     * <br>
     * \param  data                      [IN] bytes to be written
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostWriteRegister(XLportHandle, XLaccess, unsigned short, unsigned short, unsigned char, unsigned char[16])</code><br>
     * <i>native declaration : vxlapi.h:747</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostWriteRegister(com.sun.jna.NativeLong, long, short, short, byte, ByteBuffer)} and {@link #xlMostWriteRegister(com.sun.jna.NativeLong, long, short, short, byte, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlMostWriteRegister(NativeLong portHandle, long accessMask, short userHandle, short adr, byte numBytes, Pointer data);

    /**
     * \brief Allows to write up to 16 byte register in the OS8104.
     * <br>
     * This method is used to write numbyte (up to 16) bytes into the registers of the OS8104
     * <br>
     * beginning from adr. \n
     * <br>
     * ResponseEvent:                         XL_MOST_REGISTER_BYTES
     * <br>
     * \param  adr                       [IN] address (MAP) of register to which the first byte is written
     * <br>
     * \param  numBytes                  [IN] number of successive bytes to be written to the registers
     * <br>
     * \param  data                      [IN] bytes to be written
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostWriteRegister(XLportHandle, XLaccess, unsigned short, unsigned short, unsigned char, unsigned char[16])</code><br>
     * <i>native declaration : vxlapi.h:747</i>
     */
    short xlMostWriteRegister(NativeLong portHandle, long accessMask, short userHandle, short adr, byte numBytes, ByteBuffer data);

    /**
     * \brief Triggers the event XL_MOST_REGISTER_BYTES.
     * <br>
     * This method is used to read out registers of the OS8104.
     * <br>
     * The results will be delivered in the event XL_MOST_REGISTER_BYTES\n
     * <br>
     * ResponseEvent:                         XL_MOST_REGISTER_BYTES
     * <br>
     * \param  adr                       [IN] address (MAP) of register from which the first byte is read
     * <br>
     * \param  numBytes                  [IN] number of successive bytes to be read
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostReadRegister(XLportHandle, XLaccess, unsigned short, unsigned short, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:758</i>
     */
    short xlMostReadRegister(NativeLong portHandle, long accessMask, short userHandle, short adr, byte numBytes);

    /**
     * \brief Allows to write single or multiple bits of one byte register in the OS8104.
     * <br>
     * This method is used to write bits into a register of the OS8104 \n
     * <br>
     * ResponseEvent:                         XL_MOST_REGISTER_BYTES
     * <br>
     * \param  adr                       [IN] address (MAP) of the register
     * <br>
     * \param  mask                      [IN] each bit in mask corresponds to a bit in the register.
     * <br>
     * 1 means this bit will be written, 0 means that the bit is not influenced
     * <br>
     * \param  value                     [IN] the byte to be written respecting the parameter mask
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostWriteRegisterBit(XLportHandle, XLaccess, unsigned short, unsigned short, unsigned char, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:769</i>
     */
    short xlMostWriteRegisterBit(NativeLong portHandle, long accessMask, short userHandle, short adr, byte mask, byte value);

    /**
     * \brief Sending a MOST Ctrl Message.
     * <br>
     * This method is used to send a ctrl message to the MOST ring.
     * <br>
     * The members ctrlType, targetAdr, ctrlData[17], TODO: prio of pCtrlMsg will be used,
     * <br>
     * all other members don't care for the transmit request.
     * <br>
     * A XL_MOST_CTRL_MSG event will be delivered with dir==Tx and txStatus set to
     * <br>
     * report success or failure of the transmission.\n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_MSG
     * <br>
     * \param  pCtrlMsg                  [IN] structure with all relevant data needed for a transmit request
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlTransmit(XLportHandle, XLaccess, unsigned short, XLmostCtrlMsg*)</code><br>
     * <i>native declaration : vxlapi.h:782</i>
     */
    short xlMostCtrlTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_ctrl_msg pCtrlMsg);

    /**
     * \brief Sending a MOST Async Message (Packet).
     * <br>
     * This method is used to send an asynchronous message (packet) to the MOST ring.
     * <br>
     * The members arbitration, targetAdr, asyncData[1014], length, TODO: prio of pAsyncMsg will be used,
     * <br>
     * all other members don't care for the transmit request.
     * <br>
     *  TODO: arbitration has to be calculated by the sender or will be calculated by the driver/firmware?
     * <br>
     *  A XL_MOST_ASYNC_MSG event will be delivered with dir==Tx and txStatus set to
     * <br>
     *  report success or failure of the transmission.\n
     * <br>
     *  ResponseEvent:                         XL_MOST_ASYNC_MSG
     * <br>
     *  \param  pAsyncMsg                 [IN] structure with all relevant data needed for a transmit request
     * <br>
     *  \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostAsyncTransmit(XLportHandle, XLaccess, unsigned short, XLmostAsyncMsg*)</code><br>
     * <i>native declaration : vxlapi.h:795</i>
     */
    short xlMostAsyncTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_async_tx pAsyncMsg);

    /**
     * \brief Triggers the event XL_MOST_SYNC_ALLOCTABLE.
     * <br>
     * This method is used to trigger the event XL_MOST_SYNC_ALLOCTABLE,
     * <br>
     * which delivers the complete allocation table of the OS8104.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_ALLOCTABLE
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSyncGetAllocTable(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:803</i>
     */
    short xlMostSyncGetAllocTable(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Programming the routing engine (RE) for audio channels.
     * <br>
     * This method is used to program the routing engine (RE) of the OS8104 in order
     * <br>
     * to either stream audio data from the line in of VN2600 to certain MOST channels allocated before,
     * <br>
     * or to stream audio data from certain MOST channels to the headphone output of VN2600. \n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_SYNC_AUDIO
     * <br>
     * \param  channel[4]                [IN] channel numbers to be routed
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \param  mode                      [IN] audio mode
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlSyncAudio(XLportHandle, XLaccess, unsigned short, unsigned int[4], unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:815</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostCtrlSyncAudio(com.sun.jna.NativeLong, long, short, IntBuffer, int, int)} and {@link #xlMostCtrlSyncAudio(com.sun.jna.NativeLong, long, short, com.sun.jna.ptr.IntByReference, int, int)} instead
     */
    @Deprecated
    short xlMostCtrlSyncAudio(NativeLong portHandle, long accessMask, short userHandle, IntByReference channel, int device, int mode);

    /**
     * \brief Programming the routing engine (RE) for audio channels.
     * <br>
     * This method is used to program the routing engine (RE) of the OS8104 in order
     * <br>
     * to either stream audio data from the line in of VN2600 to certain MOST channels allocated before,
     * <br>
     * or to stream audio data from certain MOST channels to the headphone output of VN2600. \n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_SYNC_AUDIO
     * <br>
     * \param  channel[4]                [IN] channel numbers to be routed
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \param  mode                      [IN] audio mode
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlSyncAudio(XLportHandle, XLaccess, unsigned short, unsigned int[4], unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:815</i>
     */
    short xlMostCtrlSyncAudio(NativeLong portHandle, long accessMask, short userHandle, IntBuffer channel, int device, int mode);

    /**
     * \brief Programming the routing engine (RE) for audio channels.
     * <br>
     * This method is used to program the routing engine (RE) of the OS8104 in order
     * <br>
     * to either stream audio data from the line in of VN2600 to certain MOST channels allocated before,
     * <br>
     * or to stream audio data from certain MOST channels to the headphone output of VN2600. \n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_SYNC_AUDIO_EX
     * <br>
     * \param  channel[16]               [IN] channel numbers to be routed (including SPDIF)
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out, SPDIF in/out
     * <br>
     * \param  mode                      [IN] audio mode
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlSyncAudioEx(XLportHandle, XLaccess, unsigned short, unsigned int[16], unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:827</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostCtrlSyncAudioEx(com.sun.jna.NativeLong, long, short, IntBuffer, int, int)} and {@link #xlMostCtrlSyncAudioEx(com.sun.jna.NativeLong, long, short, com.sun.jna.ptr.IntByReference, int, int)} instead
     */
    @Deprecated
    short xlMostCtrlSyncAudioEx(NativeLong portHandle, long accessMask, short userHandle, IntByReference channel, int device, int mode);

    /**
     * \brief Programming the routing engine (RE) for audio channels.
     * <br>
     * This method is used to program the routing engine (RE) of the OS8104 in order
     * <br>
     * to either stream audio data from the line in of VN2600 to certain MOST channels allocated before,
     * <br>
     * or to stream audio data from certain MOST channels to the headphone output of VN2600. \n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_SYNC_AUDIO_EX
     * <br>
     * \param  channel[16]               [IN] channel numbers to be routed (including SPDIF)
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out, SPDIF in/out
     * <br>
     * \param  mode                      [IN] audio mode
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlSyncAudioEx(XLportHandle, XLaccess, unsigned short, unsigned int[16], unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:827</i>
     */
    short xlMostCtrlSyncAudioEx(NativeLong portHandle, long accessMask, short userHandle, IntBuffer channel, int device, int mode);

    /**
     * \brief Setting the volume/attenuation for line in and line out.
     * <br>
     * This method is used to set the volume/attenuation of the line in or line out of VN2600.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_VOLUME_STATUS
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \param  volume                    [IN] 0..255: 0..100% of volume
     * <br>
     * \return XLstatus general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSyncVolume(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:837</i>
     */
    short xlMostSyncVolume(NativeLong portHandle, long accessMask, short userHandle, int device, byte volume);

    /**
     * \brief Setting mute for line in and line out.
     * <br>
     * This method is used to switch mute on or off for the line in or line out of VN2600.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_VOLUME_STATUS
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \param  mute                      [IN] mute on/mute off
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSyncMute(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:846</i>
     */
    short xlMostSyncMute(NativeLong portHandle, long accessMask, short userHandle, int device, byte mute);

    /**
     * \brief Triggers the event XL_MOST_SYNC_VOLUME_STATUS.
     * <br>
     * This method is used to trigger the event XL_MOST_SYNC_VOLUME_STATUS,
     * <br>
     * which delivers the information about volume status of line in and line out.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_VOLUME_STATUS
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSyncGetVolumeStatus(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:855</i>
     */
    short xlMostSyncGetVolumeStatus(NativeLong portHandle, long accessMask, short userHandle, int device);

    /**
     * \brief Triggers the event XL_MOST_SYNC_MUTE_STATUS.
     * <br>
     * This method is used to trigger the event XL_MOST_SYNC_MUTE_STATUS,
     * <br>
     * which delivers the information about mute status of line in and line out.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_MUTE_STATUS
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSyncGetMuteStatus(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:864</i>
     */
    short xlMostSyncGetMuteStatus(NativeLong portHandle, long accessMask, short userHandle, int device);

    /**
     * \brief Triggers the event XL_MOST_SYNC_MUTE_STATUS.
     * <br>
     * This method delivers the recent light status at the Rx Pin of the OS8104.\n
     * <br>
     * ResponseEvent:                         XL_MOST_SYNC_MUTE_STATUS
     * <br>
     * \param  device                    [IN] device, e.g.: audio line in/audio line out
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetRxLight(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:872</i>
     */
    short xlMostGetRxLight(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Switching the Tx light of VN2600.
     * <br>
     * This method is used to switch the Tx light of VN2600 off, to normal or to constant on\n
     * <br>
     * ResponseEvent:                         XL_MOST_TXLIGHT
     * <br>
     * \param  txLight                   [IN] tx light on, off or modulated
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSetTxLight(XLportHandle, XLaccess, unsigned short, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:880</i>
     */
    short xlMostSetTxLight(NativeLong portHandle, long accessMask, short userHandle, byte txLight);

    /**
     * \brief Triggers the event XL_MOST_TXLIGHT.
     * <br>
     * This method is used to trigger the event XL_MOST_TXLIGHT,
     * <br>
     * which delivers the recent light status at the Tx Pin of the OS8104.\n
     * <br>
     * ResponseEvent:                         XL_MOST_TXLIGHT
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetTxLight(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:888</i>
     */
    short xlMostGetTxLight(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Switching the Tx light power of the FOT.
     * <br>
     * This method is used to switch the Tx light power of the FOT to normal or -3 dB\n
     * <br>
     * ResponseEvent:                         XL_MOST_TXLIGHT
     * <br>
     * \param  attenuation               [IN] tx power
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostSetLightPower(XLportHandle, XLaccess, unsigned short, unsigned char)</code><br>
     * <i>native declaration : vxlapi.h:896</i>
     */
    short xlMostSetLightPower(NativeLong portHandle, long accessMask, short userHandle, byte attenuation);

    /**
     * \brief Triggers the event XL_MOST_LOCKSTATUS.
     * <br>
     * This method is used to trigger the event XL_MOST_LOCKSTATUS,
     * <br>
     * which delivers the recent lock status at the Rx Pin of the OS8104.\n
     * <br>
     * ResponseEvent:                         XL_MOST_LOCKSTATUS
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGetLockStatus(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:906</i>
     */
    short xlMostGetLockStatus(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Starts and stops the light error generator.
     * <br>
     * This method is used to start (repeat>0) or stop (repeat==0) the light error generator
     * <br>
     * which switches the Tx light on and off or configured periods.\n
     * <br>
     * ResponseEvent:                         XL_MOST_GENLIGHTERROR
     * <br>
     * \param  lightOffTime              [IN] duration of light off in ms
     * <br>
     * \param  lightOnTime               [IN] duration of modulated light on in ms
     * <br>
     * \param  repeat                    [IN] repetition of light on light off sequence, or repeat==0: stop the generation
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGenerateLightError(XLportHandle, XLaccess, unsigned short, XLulong, XLulong, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:917</i>
     */
    short xlMostGenerateLightError(NativeLong portHandle, long accessMask, short userHandle, NativeLong lightOffTime, NativeLong lightOnTime, short repeat);

    /**
     * \brief Starts and stops the lock error generator.
     * <br>
     * This method is used to start (repeat>0) or stop (repeat==0) the lock error generator
     * <br>
     * which switches the Tx light between modulated on and permanent on for configured periods.\n
     * <br>
     * ResponseEvent:                         XL_MOST_GENLOCKERROR
     * <br>
     * \param  unmodTime                 [IN] duration of light off in ms
     * <br>
     * \param  modTime                   [IN] duration of modulated light on in ms
     * <br>
     * \param  repeat                    [IN] repetition of sequence, or repeat==0: stop the generation
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostGenerateLockError(XLportHandle, XLaccess, unsigned short, XLulong, XLulong, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:929</i>
     */
    short xlMostGenerateLockError(NativeLong portHandle, long accessMask, short userHandle, NativeLong unmodTime, NativeLong modTime, short repeat);

    /**
     * \brief prevent firmware from emptying the Rx buffer of the OS8104
     * <br>
     * This method is used to Switch the stress mode on or off, where the
     * <br>
     * Rx buffer of the OS8104 is not emptied by the firmware
     * <br>
     * which switches the Tx light between modulated on and permanent on for configured periods.\n
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_RXBUFFER
     * <br>
     * \param  bufferMode                [IN] specifies the buffer mode
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlRxBuffer(XLportHandle, XLaccess, unsigned short, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:940</i>
     */
    short xlMostCtrlRxBuffer(NativeLong portHandle, long accessMask, short userHandle, short bufferMode);

    /**
     * \brief Twinkle the power led from the VN2600.
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostTwinklePowerLed(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:946</i>
     */
    short xlMostTwinklePowerLed(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Prepares and configures busload generation with MOST control frames.
     * <br>
     * Attention: Has to be called before "xlMostCtrlGenerateBusload".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pCtrlBusloadConfiguration  [IN] structure containing the ctrl msg used for busload generation and configuration,
     * <br>
     * it's storage has has to be supplied by the caller
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlConfigureBusload(XLportHandle, XLaccess, unsigned short, XLmostCtrlBusloadConfiguration*)</code><br>
     * <i>native declaration : vxlapi.h:959</i>
     */
    short xlMostCtrlConfigureBusload(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_ctrl_busload_configuration pCtrlBusloadConfiguration);

    /**
     * \brief Starts busload generation with MOST control frames.
     * <br>
     * Attention: "xlMostCtrlConfigureBusload" has to be called before.
     * <br>
     * ResponseEvent:                         XL_MOST_CTRL_BUSLOAD
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param numberCtrlFrames           [IN] number of busload ctrl messages (0xFFFFFFFF indicates infinite number of messages)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostCtrlGenerateBusload(XLportHandle, XLaccess, unsigned short, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:972</i>
     */
    short xlMostCtrlGenerateBusload(NativeLong portHandle, long accessMask, short userHandle, NativeLong numberCtrlFrames);

    /**
     * \brief Prepares and configures busload generation of MOST asynchronous frames.
     * <br>
     * Attention: Has to be called before "xlMostAsyncGenerateBusload".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pAsyncBusloadConfiguration [IN] structure containing the async msg used for busload generation and configuration,
     * <br>
     * it's storage has has to be supplied by the caller
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostAsyncConfigureBusload(XLportHandle, XLaccess, unsigned short, XLmostAsyncBusloadConfiguration*)</code><br>
     * <i>native declaration : vxlapi.h:985</i>
     */
    short xlMostAsyncConfigureBusload(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_async_busload_configuration pAsyncBusloadConfiguration);

    /**
     * \brief Starts busload generation with MOST asynchronous frames.
     * <br>
     * Attention: "xlMostAsyncConfigureBusload" has to be called before.
     * <br>
     * ResponseEvent:                         XL_MOST_ASYNC_BUSLOAD
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param numberAsyncFrames          [IN] number of busload async messages (0xFFFFFFFF indicates infinite number of messages)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostAsyncGenerateBusload(XLportHandle, XLaccess, unsigned short, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:998</i>
     */
    short xlMostAsyncGenerateBusload(NativeLong portHandle, long accessMask, short userHandle, NativeLong numberAsyncFrames);

    /**
     * \brief Opens a stream (Rx / Tx) for routing synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called before "xlMostStreamBufferAllocate".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pStreamOpen                [IN] structure containing the stream parameters -
     * <br>
     * it's storage has has to be supplied by the caller
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamOpen(XLportHandle, XLaccess, unsigned short, XLmostStreamOpen*)</code><br>
     * <i>native declaration : vxlapi.h:1012</i>
     */
    short xlMostStreamOpen(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_stream_open pStreamOpen);

    /**
     * \brief Closes an opened a stream (Rx / Tx) used for routing synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamClose(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1023</i>
     */
    short xlMostStreamClose(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Starts the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called after "xlMostStreamOpen and xlMostStreamBufferAllocate" were called.
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param syncChannels               [IN] synchronous channels (bytes) used for streaming.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamStart(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char[60])</code><br>
     * <i>native declaration : vxlapi.h:1036</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostStreamStart(com.sun.jna.NativeLong, long, short, int, ByteBuffer)} and {@link #xlMostStreamStart(com.sun.jna.NativeLong, long, short, int, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    short xlMostStreamStart(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, Pointer syncChannels);

    /**
     * \brief Starts the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called after "xlMostStreamOpen and xlMostStreamBufferAllocate" were called.
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param syncChannels               [IN] synchronous channels (bytes) used for streaming.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamStart(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char[60])</code><br>
     * <i>native declaration : vxlapi.h:1036</i>
     */
    short xlMostStreamStart(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, ByteBuffer syncChannels);

    /**
     * \brief Stops the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called before "xlMostStreamBufferDeallocate".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamStop(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1048</i>
     */
    short xlMostStreamStop(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Allocates a buffer for streaming (RX / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called before "xlMostStreamStart".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param ppBuffer                  [OUT] pointer to the buffer used for streaming
     * <br>
     * memory allocation is done by the driver
     * <br>
     * has to be released by calling xlMostStreamBufferDeallocate
     * <br>
     * \param pBufferSize               [OUT] buffer size.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferAllocate(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char**, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1064</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostStreamBufferAllocate(com.sun.jna.NativeLong, long, short, int, com.sun.jna.ptr.PointerByReference, IntBuffer)} and {@link #xlMostStreamBufferAllocate(com.sun.jna.NativeLong, long, short, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlMostStreamBufferAllocate(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, PointerByReference ppBuffer, IntByReference pBufferSize);

    /**
     * \brief Allocates a buffer for streaming (RX / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called before "xlMostStreamStart".
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param ppBuffer                  [OUT] pointer to the buffer used for streaming
     * <br>
     * memory allocation is done by the driver
     * <br>
     * has to be released by calling xlMostStreamBufferDeallocate
     * <br>
     * \param pBufferSize               [OUT] buffer size.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferAllocate(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char**, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1064</i>
     */
    short xlMostStreamBufferAllocate(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, PointerByReference ppBuffer, IntBuffer pBufferSize);

    /**
     * \brief Deallocates any buffer allocated with "xlMostStreamBufferAllocate".
     * <br>
     * Attention: Has to be called before "xlMostStreamClose". Afterwards no buffer must be accessed!
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferDeallocateAll(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1077</i>
     */
    short xlMostStreamBufferDeallocateAll(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Notifies the driver the next buffer to be used for streaming synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param pBuffer                    [IN] pointer to the next buffer used for streaming
     * <br>
     * \param filledBytes                [IN] size of  the next buffer to be used for streaming
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferSetNext(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1090</i><br>
     *
     * @deprecated use the safer methods {@link #xlMostStreamBufferSetNext(com.sun.jna.NativeLong, long, short, int, ByteBuffer, int)} and {@link #xlMostStreamBufferSetNext(com.sun.jna.NativeLong, long, short, int, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    short xlMostStreamBufferSetNext(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, Pointer pBuffer, int filledBytes);

    /**
     * \brief Notifies the driver the next buffer to be used for streaming synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param pBuffer                    [IN] pointer to the next buffer used for streaming
     * <br>
     * \param filledBytes                [IN] size of  the next buffer to be used for streaming
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferSetNext(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1090</i>
     */
    short xlMostStreamBufferSetNext(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, ByteBuffer pBuffer, int filledBytes);

    /**
     * \brief Retrieves the stream information.
     * <br>
     * This method is used to gather the recent stream state information.\n
     * <br>
     * ResponseEvent:                         None
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pStreamInfo               [OUT] Pointer to the stream information.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamGetInfo(XLportHandle, XLaccess, unsigned short, XLmostStreamInfo*)</code><br>
     * <i>native declaration : vxlapi.h:1103</i>
     */
    short xlMostStreamGetInfo(NativeLong portHandle, long accessMask, short userHandle, s_xl_most_stream_info pStreamInfo);

    /**
     * \brief Clears the content of the buffer(s) which are not already sent.
     * <br>
     * This method is used to clear the content of any TX streaming buffer which has not been sent yet.\n
     * <br>
     * ResponseEvent:                         None
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMostStreamBufferClearAll(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1115</i>
     */
    short xlMostStreamBufferClearAll(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSetConfiguration(XLportHandle, XLaccess, XLfrClusterConfig*)</code><br>
     * <i>native declaration : vxlapi.h:1129</i>
     */
    short xlFrSetConfiguration(NativeLong portHandle, long accessMask, s_xl_fr_cluster_configuration pxlClusterConfig);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrGetChannelConfiguration(XLportHandle, XLaccess, XLfrChannelConfig*)</code><br>
     * <i>native declaration : vxlapi.h:1140</i>
     */
    short xlFrGetChannelConfiguration(NativeLong portHandle, long accessMask, s_xl_fr_channel_config pxlFrChannelConfig);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSetMode(XLportHandle, XLaccess, XLfrMode*)</code><br>
     * <i>native declaration : vxlapi.h:1150</i>
     */
    short xlFrSetMode(NativeLong portHandle, long accessMask, s_xl_fr_set_modes pxlFrMode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrInitStartupAndSync(XLportHandle, XLaccess, XLfrEvent*)</code><br>
     * <i>native declaration : vxlapi.h:1160</i>
     */
    short xlFrInitStartupAndSync(NativeLong portHandle, long accessMask, s_xl_fr_event pEventBuffer);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSetupSymbolWindow(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1171</i>
     */
    short xlFrSetupSymbolWindow(NativeLong portHandle, long accessMask, int frChannel, int symbolWindowMask);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrReceive(XLportHandle, XLfrEvent*)</code><br>
     * <i>native declaration : vxlapi.h:1180</i>
     */
    short xlFrReceive(NativeLong portHandle, s_xl_fr_event pEventBuffer);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrTransmit(XLportHandle, XLaccess, XLfrEvent*)</code><br>
     * <i>native declaration : vxlapi.h:1190</i>
     */
    short xlFrTransmit(NativeLong portHandle, long accessMask, s_xl_fr_event pEventBuffer);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSetTransceiverMode(XLportHandle, XLaccess, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1201</i>
     */
    short xlFrSetTransceiverMode(NativeLong portHandle, long accessMask, int frChannel, int mode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSendSymbolWindow(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1211</i>
     */
    short xlFrSendSymbolWindow(NativeLong portHandle, long accessMask, int symbolWindow);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrActivateSpy(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1221</i>
     */
    short xlFrActivateSpy(NativeLong portHandle, long accessMask, int mode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlFrSetAcceptanceFilter(XLportHandle, XLaccess, XLfrAcceptanceFilter*)</code><br>
     * <i>native declaration : vxlapi.h:1230</i>
     */
    short xlFrSetAcceptanceFilter(NativeLong portHandle, long accessMask, s_xl_fr_acceptance_filter pAcceptanceFilter);

    /**
     * \brief The application gets the information, which remote channels are available in the system. The user
     * <br>
     * must provide the memory (pointer to XLdriverConfig structure).
     * <br>
     * \param pDriverConfig              [OUT] The remote driver configuration structure.
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteDriverConfig(XLdriverConfig*)</code><br>
     * <i>native declaration : vxlapi.h:1237</i>
     */
    short xlGetRemoteDriverConfig(s_xl_driver_config pDriverConfig);

    /**
     * \brief The application gets the available RDNI network devices. The buffer is allocated by DLL and can be
     * <br>
     * freed by a call of xlReleaseRemoteDeviceInfo. This API function is not thread safe.
     * <br>
     * \param deviceList                 [OUT] Pointer receiving the address of the buffer containing the device configuration information.
     * <br>
     * \param nbrOfRemoteDevices         [OUT] The number of available network devices.
     * <br>
     * \param netSearch                  [IN] One of the defines: XL_REMOTE_NET_SEARCH or XL_REMOTE_NO_NET_SEARCH
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteDeviceInfo(XLremoteDeviceInfo**, unsigned int*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1247</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetRemoteDeviceInfo(s_xl_remote_device_info.ByReference[], IntBuffer, int)} and {@link #xlGetRemoteDeviceInfo(s_xl_remote_device_info.ByReference[], com.sun.jna.ptr.IntByReference, int)} instead
     */
    @Deprecated
    short xlGetRemoteDeviceInfo(PointerByReference deviceList, IntByReference nbrOfRemoteDevices, int netSearch);

    /**
     * \brief The application gets the available RDNI network devices. The buffer is allocated by DLL and can be
     * <br>
     * freed by a call of xlReleaseRemoteDeviceInfo. This API function is not thread safe.
     * <br>
     * \param deviceList                 [OUT] Pointer receiving the address of the buffer containing the device configuration information.
     * <br>
     * \param nbrOfRemoteDevices         [OUT] The number of available network devices.
     * <br>
     * \param netSearch                  [IN] One of the defines: XL_REMOTE_NET_SEARCH or XL_REMOTE_NO_NET_SEARCH
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteDeviceInfo(XLremoteDeviceInfo**, unsigned int*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1247</i>
     */
    short xlGetRemoteDeviceInfo(s_xl_remote_device_info.ByReference deviceList[], IntBuffer nbrOfRemoteDevices, int netSearch);

    /**
     * \brief The application gets the available RDNI network devices. The buffer is allocated by DLL and can be
     * <br>
     * freed by a call of xlReleaseRemoteDeviceInfo. This API function is not thread safe.
     * <br>
     * \param deviceList                 [OUT] Pointer receiving the address of the buffer containing the device configuration information.
     * <br>
     * \param nbrOfRemoteDevices         [OUT] The number of available network devices.
     * <br>
     * \param netSearch                  [IN] One of the defines: XL_REMOTE_NET_SEARCH or XL_REMOTE_NO_NET_SEARCH
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteDeviceInfo(XLremoteDeviceInfo**, unsigned int*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1247</i>
     */
    short xlGetRemoteDeviceInfo(s_xl_remote_device_info.ByReference deviceList[], IntByReference nbrOfRemoteDevices, int netSearch);

    /**
     * \brief Frees the buffer allocated by a call to xlGetRemoteDeviceInfo.
     * <br>
     * \param deviceList                 [IN] Pointer containing the address of the buffer.
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlReleaseRemoteDeviceInfo(XLremoteDeviceInfo**)</code><br>
     * <i>native declaration : vxlapi.h:1254</i><br>
     *
     * @deprecated use the safer method {@link #xlReleaseRemoteDeviceInfo(s_xl_remote_device_info.ByReference[])} instead
     */
    @Deprecated
    short xlReleaseRemoteDeviceInfo(PointerByReference deviceList);

    /**
     * \brief Frees the buffer allocated by a call to xlGetRemoteDeviceInfo.
     * <br>
     * \param deviceList                 [IN] Pointer containing the address of the buffer.
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlReleaseRemoteDeviceInfo(XLremoteDeviceInfo**)</code><br>
     * <i>native declaration : vxlapi.h:1254</i>
     */
    short xlReleaseRemoteDeviceInfo(s_xl_remote_device_info.ByReference deviceList[]);

    /**
     * \brief The application establishes a connection to a RDNI network device.
     * <br>
     * \param remoteHandle               [IN] DLL internal handle of the device retrieved by a call to xlGetRemoteDeviceInfo.
     * <br>
     * \param deviceMask                 [IN] not used
     * <br>
     * \param flags                      [IN] specify if the connection shall be permanent or temporary (until next reboot)
     * <br>
     * One of the defines: XL_REMOTE_ADD_PERMANENT, XL_REMOTE_ADD_TEMPORARY
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlAddRemoteDevice(XLremoteHandle, XLdeviceAccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1264</i>
     */
    short xlAddRemoteDevice(int remoteHandle, int deviceMask, int flags);

    /**
     * \brief The application closes a connection to a RDNI network device.
     * <br>
     * \param remoteHandle               [IN] DLL internal handle of the device retrieved by a call to xlGetRemoteDeviceInfo.
     * <br>
     * \param deviceMask                 [IN] not used
     * <br>
     * \param flags                      [IN] Server entry removal flag.
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlRemoveRemoteDevice(XLremoteHandle, XLdeviceAccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1273</i>
     */
    short xlRemoveRemoteDevice(int remoteHandle, int deviceMask, int flags);

    /**
     * \brief Updates a list of remote device information objects
     * <br>
     * \param deviceList                 [IN] An array of device information objects to be updated
     * <br>
     * \param nbrOfRemoteDevices         [IN] Number of elements in the list.
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlUpdateRemoteDeviceInfo(XLremoteDeviceInfo*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1282</i>
     */
    short xlUpdateRemoteDeviceInfo(s_xl_remote_device_info deviceList, int nbrOfRemoteDevices);

    /**
     * \brief Retrieves the hardware type and hardware index of the channels in driver config structure that belong to the remote device.
     * <br>
     * \param remoteHandle               [IN]  Handle of the remote device.
     * <br>
     * \param hwType                     [OUT] Hardware type of the channels.
     * <br>
     * \param hwIndex                    [OUT] Hardware index of the channels.
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteHwInfo(XLremoteHandle, int*, int*, int*)</code><br>
     * <i>native declaration : vxlapi.h:1292</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetRemoteHwInfo(int, IntBuffer, IntBuffer, IntBuffer)} and {@link #xlGetRemoteHwInfo(int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlGetRemoteHwInfo(int remoteHandle, IntByReference hwType, IntByReference hwIndex, IntByReference isPresent);

    /**
     * \brief Retrieves the hardware type and hardware index of the channels in driver config structure that belong to the remote device.
     * <br>
     * \param remoteHandle               [IN]  Handle of the remote device.
     * <br>
     * \param hwType                     [OUT] Hardware type of the channels.
     * <br>
     * \param hwIndex                    [OUT] Hardware index of the channels.
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetRemoteHwInfo(XLremoteHandle, int*, int*, int*)</code><br>
     * <i>native declaration : vxlapi.h:1292</i>
     */
    short xlGetRemoteHwInfo(int remoteHandle, IntBuffer hwType, IntBuffer hwIndex, IntBuffer isPresent);

    /**
     * \brief Registers a manual configured network node.
     * <br>
     * \param hwType                     [IN]  Hardware type of the device to be registered.
     * <br>
     * \param ipAddress                  [IN]  IP address of the device.
     * <br>
     * \param flags                      [IN]  Specify one of the defines:
     * <br>
     * XL_REMOTE_REGISTER_NONE, XL_REMOTE_REGISTER_CONNECT, XL_REMOTE_REGISTER_TEMP_CONNECT
     * <br>
     * <br>
     * \return XLstatus                        general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlRegisterRemoteDevice(int, XLipAddress*, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1303</i>
     */
    short xlRegisterRemoteDevice(int hwType, s_xl_ip_address ipAddress, int flags);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoSetTriggerMode(XLportHandle, XLaccess, XLdaioTriggerMode*)</code><br>
     * <i>native declaration : vxlapi.h:1316</i>
     */
    short xlIoSetTriggerMode(NativeLong portHandle, long accessMask, s_xl_daio_trigger_mode pxlDaioTriggerMode);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoSetDigitalOutput(XLportHandle, XLaccess, XLdaioDigitalParams*)</code><br>
     * <i>native declaration : vxlapi.h:1323</i>
     */
    short xlIoSetDigitalOutput(NativeLong portHandle, long accessMask, xl_daio_digital_params pxlDaioDigitalParams);

    /**
     * \brief Setup the DAIO ports.
     * <br>
     * \param pxlDaioSetPort          [IN] Pointer to the XLdaioSetPort structure.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoConfigurePorts(XLportHandle, XLaccess, XLdaioSetPort*)</code><br>
     * <i>native declaration : vxlapi.h:1330</i>
     */
    short xlIoConfigurePorts(NativeLong portHandle, long accessMask, xl_daio_set_port pxlDaioSetPort);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoSetDigInThreshold(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1337</i>
     */
    short xlIoSetDigInThreshold(NativeLong portHandle, long accessMask, int level);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoSetDigOutLevel(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1344</i>
     */
    short xlIoSetDigOutLevel(NativeLong portHandle, long accessMask, int level);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoSetAnalogOutput(XLportHandle, XLaccess, XLdaioAnalogParams*)</code><br>
     * <i>native declaration : vxlapi.h:1351</i>
     */
    short xlIoSetAnalogOutput(NativeLong portHandle, long accessMask, xl_daio_analog_params pxlDaioAnalogParams);

    /**
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlIoStartSampling(XLportHandle, XLaccess, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1358</i>
     */
    short xlIoStartSampling(NativeLong portHandle, long accessMask, int portTypeMask);

    /**
     * \brief fetching events from driver queue.
     * <br>
     * This method is used to fetch events, either bus events or acknowledgments
     * <br>
     * for commands from the driver queue. Each call delivers only one event (if an event is available). \n
     * <br>
     * It is a synchronous mode and either delivers event data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channels an API should work
     * <br>
     * \param  pEventBuffer              [IN] This parameter must point to a buffer to which the driver can copy
     * <br>
     * the next event of the receive queue
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150Receive(XLportHandle, XLmost150event*)</code><br>
     * <i>native declaration : vxlapi.h:1392</i>
     */
    short xlMost150Receive(NativeLong portHandle, s_xl_event_most150 pEventBuffer);

    /**
     * \brief Twinkle the power led from the VN2640.
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150TwinklePowerLed(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1398</i>
     */
    short xlMost150TwinklePowerLed(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Activates or deactivates the different event sources of VN2640.
     * <br>
     * This method is used to select which bus events should be delivered by VN2640.
     * <br>
     * ResponseEvent:                         XL_MOST150_EVENT_SOURCE
     * <br>
     * \param sourceMask                 [IN] each bit stands for an event source and can separately be set.
     * <br>
     * Use the definitions of the source mask (see XL_MOST150_SOURCE_...).
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SwitchEventSources(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1407</i>
     */
    short xlMost150SwitchEventSources(NativeLong portHandle, long accessMask, short userHandle, int sourceMask);

    /**
     * \brief Sets the device mode.
     * <br>
     * This method is used to switch the device mode to either Master, Slave or bypass \n
     * <br>
     * ResponseEvent:                         XL_MOST150_DEVICE_MODE
     * <br>
     * \param  deviceMode                [IN] device mode (see XL_MOST150_DEVICEMODE_...)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetDeviceMode(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1416</i>
     */
    short xlMost150SetDeviceMode(NativeLong portHandle, long accessMask, short userHandle, int deviceMode);

    /**
     * \brief Requests the current device mode.
     * <br>
     * This method is asynchronous and requests the event used to switch device mode.
     * <br>
     * ResponseEvent:                         XL_MOST150_DEVICE_MODE
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetDeviceMode(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1423</i>
     */
    short xlMost150GetDeviceMode(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Switches the SPDIF mode to slave or master mode.
     * <br>
     * This method is used to switch into the SPDIF master or SPDIF slave mode \n
     * <br>
     * ResponseEvent:                         XL_MOST150_SPDIFMODE
     * <br>
     * \param  spdifMode                 [IN] MOST master/slave, ...
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetSPDIFMode(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1431</i>
     */
    short xlMost150SetSPDIFMode(NativeLong portHandle, long accessMask, short userHandle, int spdifMode);

    /**
     * \brief Requests the current SPDIF mode.
     * <br>
     * This method is used to trigger the event XL_MOST150_SPDIFMODE, which will deliver
     * <br>
     * information whether the SPDIF is configured in slave or master mode.\n
     * <br>
     * ResponseEvent:                         XL_MOST150_SPDIFMODE
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetSPDIFMode(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1439</i>
     */
    short xlMost150GetSPDIFMode(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Set one or more parameters of the special node info at once.
     * <br>
     * ResponseEvent:                         XL_MOST150_SPECIAL_NODE_INFO
     * <br>
     * \param  pSpecialNodeInfo          [IN] contains the parameter to set
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetSpecialNodeInfo(XLportHandle, XLaccess, unsigned short, XLmost150SetSpecialNodeInfo*)</code><br>
     * <i>native declaration : vxlapi.h:1447</i>
     */
    short xlMost150SetSpecialNodeInfo(NativeLong portHandle, long accessMask, short userHandle, s_xl_set_most150_special_node_info pSpecialNodeInfo);

    /**
     * \brief Requests one or more parameters of the special node info at once.
     * <br>
     * ResponseEvent:                         XL_MOST150_SPECIAL_NODE_INFO
     * <br>
     * \param  requestMask               [IN] contains a mask of parameter to get (see XL_MOST150_SPECIAL_NODE_MASK_CHANGED)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetSpecialNodeInfo(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1454</i>
     */
    short xlMost150GetSpecialNodeInfo(NativeLong portHandle, long accessMask, short userHandle, int requestMask);

    /**
     * \brief Set the frequency of the MOST150 ring.
     * <br>
     * ResponseEvent:                         XL_MOST150_FREQUENCY
     * <br>
     * \param  frequency                 [IN] contains the frequency to be set. Only as timing master! (see XL_MOST150_FREQUENCY_...)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetFrequency(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1461</i>
     */
    short xlMost150SetFrequency(NativeLong portHandle, long accessMask, short userHandle, int frequency);

    /**
     * \brief Requests the frequency of the MOST150 ring.
     * <br>
     * ResponseEvent:                         XL_MOST150_FREQUENCY
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetFrequency(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1467</i>
     */
    short xlMost150GetFrequency(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Transmit a control message on the MOST150 ring.
     * <br>
     * ResponseEvent:                         XL_MOST150_CTRL_TX
     * <br>
     * \param  pCtrlTxMsg                [IN] pointer to structure that contains the control message to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150CtrlTransmit(XLportHandle, XLaccess, unsigned short, XLmost150CtrlTxMsg*)</code><br>
     * <i>native declaration : vxlapi.h:1474</i>
     */
    short xlMost150CtrlTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_ctrl_tx_msg pCtrlTxMsg);

    /**
     * \brief Transmit a data packet (MDP) on the MOST150 ring.
     * <br>
     * ResponseEvent:                         XL_MOST150_ASYNC_TX
     * <br>
     * \param  pAsyncTxMsg               [IN] pointer to structure that contains the MOST Data Packet (MDP) to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150AsyncTransmit(XLportHandle, XLaccess, unsigned short, XLmost150AsyncTxMsg*)</code><br>
     * <i>native declaration : vxlapi.h:1481</i>
     */
    short xlMost150AsyncTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_async_tx_msg pAsyncTxMsg);

    /**
     * \brief Transmit a Ethernet packet (MEP) on the MOST150 ring.
     * <br>
     * ResponseEvent:                         XL_MOST150_ETHERNET_TX
     * <br>
     * \param  pEthernetTxMsg            [IN] pointer to structure that contains the MOST Ethernet Packet (MEP) to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150EthernetTransmit(XLportHandle, XLaccess, unsigned short, XLmost150EthernetTxMsg*)</code><br>
     * <i>native declaration : vxlapi.h:1488</i>
     */
    short xlMost150EthernetTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_ethernet_tx_msg pEthernetTxMsg);

    /**
     * \brief Requests the state of the system lock flag.
     * <br>
     * ResponseEvent:                         XL_MOST150_SYSTEMLOCK_FLAG
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetSystemLockFlag(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1494</i>
     */
    short xlMost150GetSystemLockFlag(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Requests the state of the shutdown flag.
     * <br>
     * ResponseEvent:                         XL_MOST150_SHUTDOWN_FLAG
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetShutdownFlag(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1500</i>
     */
    short xlMost150GetShutdownFlag(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Shutdown the MOST150 ring.
     * <br>
     * ResponseEvent:
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150Shutdown(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1506</i>
     */
    short xlMost150Shutdown(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Startup the MOST150 ring.
     * <br>
     * ResponseEvent:
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150Startup(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1512</i>
     */
    short xlMost150Startup(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Requests the current allocation information.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_SYNC_ALLOC_INFO
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SyncGetAllocTable(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1519</i>
     */
    short xlMost150SyncGetAllocTable(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Set the parameters for audio functions.
     * <br>
     * ResponseEvent:                         XL_MOST150_CTRL_SYNC_AUDIO
     * <br>
     * \param  pSyncAudioParameter       [IN] pointer to structure that contains the data
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150CtrlSyncAudio(XLportHandle, XLaccess, unsigned short, XLmost150SyncAudioParameter*)</code><br>
     * <i>native declaration : vxlapi.h:1526</i>
     */
    short xlMost150CtrlSyncAudio(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_sync_audio_parameter pSyncAudioParameter);

    /**
     * \brief Set the volume of Line In/Out audio device.
     * <br>
     * ResponseEvent:                         XL_MOST150_SYNC_VOLUME_STATUS
     * <br>
     * \param  device                    [IN] specifies the device (see XL_MOST150_DEVICE_LINE_IN, ...)
     * <br>
     * \param  volume                    [IN] specifies the volume
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SyncSetVolume(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1534</i>
     */
    short xlMost150SyncSetVolume(NativeLong portHandle, long accessMask, short userHandle, int device, int volume);

    /**
     * \brief Requests the volume of Line In/Out audio device.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_SYNC_VOLUME_STATUS
     * <br>
     * \param  device                    [IN] specifies the device (see XL_MOST150_DEVICE_LINE_IN, ...)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SyncGetVolume(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1542</i>
     */
    short xlMost150SyncGetVolume(NativeLong portHandle, long accessMask, short userHandle, int device);

    /**
     * \brief Set mute state of Line In/Out or S/PDIF In/Out audio device.
     * <br>
     * ResponseEvent:                         XL_MOST150_SYNC_MUTE_STATUS
     * <br>
     * \param  device                    [IN] specifies the device (see XL_MOST150_DEVICE_...)
     * <br>
     * \param  mute                      [IN] specifies the mute status (on / off)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SyncSetMute(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1550</i>
     */
    short xlMost150SyncSetMute(NativeLong portHandle, long accessMask, short userHandle, int device, int mute);

    /**
     * \brief Requests mute state of Line In/Out or S/PDIF In/Out audio device.
     * <br>
     * ResponseEvent:                         XL_MOST150_SYNC_MUTE_STATUS
     * <br>
     * \param  device                    [IN] specifies the device (see XL_MOST150_DEVICE_LINE_IN, ...)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SyncGetMute(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1557</i>
     */
    short xlMost150SyncGetMute(NativeLong portHandle, long accessMask, short userHandle, int device);

    /**
     * \brief Requests the FOR and lock status either from the spy or from INIC.
     * <br>
     * ResponseEvent:                         XL_MOST150_RXLIGHT_LOCKSTATUS
     * <br>
     * \param  fromSpy                   [IN] defines the source, to get the light & lock status from
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetRxLightLockStatus(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1564</i>
     */
    short xlMost150GetRxLightLockStatus(NativeLong portHandle, long accessMask, short userHandle, int fromSpy);

    /**
     * \brief Set the FOT output mode.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_TX_LIGHT
     * <br>
     * \param  txLight                   [IN] mode of the output (modulated (on) or off)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetTxLight(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1572</i>
     */
    short xlMost150SetTxLight(NativeLong portHandle, long accessMask, short userHandle, int txLight);

    /**
     * \brief Requests the FOT output mode.
     * <br>
     * ResponseEvent:                         XL_MOST150_TX_LIGHT
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetTxLight(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1578</i>
     */
    short xlMost150GetTxLight(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Set the FOT output power.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_LIGHT_POWER
     * <br>
     * \param  attenuation               [IN] tx light power (no attenuation / -3dB attenuation)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetTxLightPower(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1586</i>
     */
    short xlMost150SetTxLightPower(NativeLong portHandle, long accessMask, short userHandle, int attenuation);

    /**
     * \brief Controls the light error generation.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_GEN_LIGHT_ERROR
     * <br>
     * \param  lightOffTime              [IN] duration of light off in [ms]
     * <br>
     * \param  lightOnTime               [IN] duration of light on in [ms]
     * <br>
     * \param  repeat                    [IN] number of error intervals
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GenerateLightError(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1596</i>
     */
    short xlMost150GenerateLightError(NativeLong portHandle, long accessMask, short userHandle, int lightOffTime, int lightOnTime, int repeat);

    /**
     * \brief Control the lock error generation.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_GEN_LOCK_ERROR
     * <br>
     * \param  unlockTime                [IN] duration of unlock in [ms]
     * <br>
     * \param  lockTime                  [IN] duration of lock in [ms]
     * <br>
     * \param  repeat                    [IN] number of error intervals
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GenerateLockError(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1607</i>
     */
    short xlMost150GenerateLockError(NativeLong portHandle, long accessMask, short userHandle, int unlockTime, int lockTime, int repeat);

    /**
     * \brief Configures the receive buffer for control messages and packets of the INIC.
     * <br>
     * \n
     * <br>
     * ResponseEvent:                         XL_MOST150_CONFIGURE_RX_BUFFER
     * <br>
     * \param  bufferType                [IN] Bit mask for receive buffer type (control messages and/or packets (MDP/MEP)).
     * <br>
     * \param  bufferMode                [IN] Block or un-block receive buffer
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150ConfigureRxBuffer(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1617</i>
     */
    short xlMost150ConfigureRxBuffer(NativeLong portHandle, long accessMask, short userHandle, int bufferType, int bufferMode);

    /**
     * \brief Defines the control message which should be transmitted with xlMost150CtrlGenerateBusload().
     * <br>
     * ResponseEvent:
     * <br>
     * \param  pCtrlBusLoad              [IN] pointer to structure that contains the control message
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150CtrlConfigureBusload(XLportHandle, XLaccess, unsigned short, XLmost150CtrlBusloadConfig*)</code><br>
     * <i>native declaration : vxlapi.h:1624</i>
     */
    short xlMost150CtrlConfigureBusload(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_ctrl_busload_config pCtrlBusLoad);

    /**
     * \brief Starts or stops the control message busload by sending the control message defined with xlMost150CtrlConfigureBusload().
     * <br>
     * ResponseEvent:                        XL_MOST150_CTRL_BUSLOAD
     * <br>
     * \param  numberCtrlFrames         [IN] number of control messages to be sent
     * <br>
     * 0:            stop sending
     * <br>
     * < 0xFFFFFFFF: number of messages to be sent
     * <br>
     * 0xFFFFFFFF:   send continuously
     * <br>
     * \return XLstatus                      general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150CtrlGenerateBusload(XLportHandle, XLaccess, unsigned short, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:1634</i>
     */
    short xlMost150CtrlGenerateBusload(NativeLong portHandle, long accessMask, short userHandle, NativeLong numberCtrlFrames);

    /**
     * \brief Define the data or Ethernet packet that should be transmitted with xlMost150AsyncGenerateBusload().
     * <br>
     * ResponseEvent:
     * <br>
     * \param  pAsyncBusLoad             [IN] pointer to structure that contains either the data or the Ethernet packet
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150AsyncConfigureBusload(XLportHandle, XLaccess, unsigned short, XLmost150AsyncBusloadConfig*)</code><br>
     * <i>native declaration : vxlapi.h:1641</i>
     */
    short xlMost150AsyncConfigureBusload(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_async_busload_config pAsyncBusLoad);

    /**
     * \brief Starts or stops the packet busload by sending either the data or Ethernet packet defined with xlMost150AsyncConfigureBusload().
     * <br>
     * ResponseEvent:                         XL_MOST150_ASYNC_BUSLOAD
     * <br>
     * \param  numberAsyncPackets        [IN] number of data or Ethernet packets to be sent
     * <br>
     * 0:            stop sending
     * <br>
     * < 0xFFFFFFFF: number of packets to be sent
     * <br>
     * 0xFFFFFFFF:   send continuously
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150AsyncGenerateBusload(XLportHandle, XLaccess, unsigned short, XLulong)</code><br>
     * <i>native declaration : vxlapi.h:1651</i>
     */
    short xlMost150AsyncGenerateBusload(NativeLong portHandle, long accessMask, short userHandle, NativeLong numberAsyncPackets);

    /**
     * \brief Set the ECL state.
     * <br>
     * ResponseEvent:                         XL_MOST150_ECL_LINE_CHANGED
     * <br>
     * \param  eclLineState              [IN] ECL state to be set: XL_MOST150_ECL_LINE_LOW, XL_MOST150_ECL_LINE_HIGH
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetECLLine(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1659</i>
     */
    short xlMost150SetECLLine(NativeLong portHandle, long accessMask, short userHandle, int eclLineState);

    /**
     * \brief Set the ECL termination resistor state.
     * <br>
     * ResponseEvent:                         XL_MOST150_ECL_TERMINATION_CHANGED
     * <br>
     * \param  eclLineTermination        [IN] ECL line termination resistor state to be set:
     * <br>
     * XL_MOST150_ECL_LINE_PULL_UP_NOT_ACTIVE, XL_MOST150_ECL_LINE_PULL_UP_ACTIVE
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetECLTermination(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1667</i>
     */
    short xlMost150SetECLTermination(NativeLong portHandle, long accessMask, short userHandle, int eclLineTermination);

    /**
     * \brief Requests the current ECL state and settings.
     * <br>
     * This method is asynchronous and requests the event used to get the ECL line state, termination and glitch filter setting.
     * <br>
     * ResponseEvent:                         XL_MOST150_ECL_LINE_CHANGED, XL_MOST150_ECL_TERMINATION_CHANGED, XL_MOST150_ECL_GLITCH_FILTER
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetECLInfo(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1674</i>
     */
    short xlMost150GetECLInfo(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Opens a stream (Rx / Tx) for routing synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_STATE
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pStreamOpen                [IN] structure containing the stream parameters -
     * <br>
     * it's storage has has to be supplied by the caller
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamOpen(XLportHandle, XLaccess, unsigned short, XLmost150StreamOpen*)</code><br>
     * <i>native declaration : vxlapi.h:1686</i>
     */
    short xlMost150StreamOpen(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_stream_open pStreamOpen);

    /**
     * \brief Closes an opened a stream (Rx / Tx) used for routing synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_STATE
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamClose(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1697</i>
     */
    short xlMost150StreamClose(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Starts the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called after XL_MOST150_STREAM_STATE "Opened" was received.
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_STATE
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param numConnLabels              [IN] Number of connection labels to stream (only used for Rx streaming, max. 8 labels can be
     * <br>
     * streamed!) \param pConnLabels                [IN] connection label(s) (only used for Rx streaming) \return XLstatus general status
     * <br>
     * information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamStart(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1711</i><br>
     *
     * @deprecated use the safer methods {@link #xlMost150StreamStart(com.sun.jna.NativeLong, long, short, int, int, IntBuffer)} and {@link #xlMost150StreamStart(com.sun.jna.NativeLong, long, short, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlMost150StreamStart(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, int numConnLabels, IntByReference pConnLabels);

    /**
     * \brief Starts the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called after XL_MOST150_STREAM_STATE "Opened" was received.
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_STATE
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param numConnLabels              [IN] Number of connection labels to stream (only used for Rx streaming, max. 8 labels can be
     * <br>
     * streamed!) \param pConnLabels                [IN] connection label(s) (only used for Rx streaming) \return XLstatus general status
     * <br>
     * information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamStart(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1711</i>
     */
    short xlMost150StreamStart(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, int numConnLabels, IntBuffer pConnLabels);

    /**
     * \brief Stops the streaming (Rx / Tx) of synchronous data to or from the MOST bus (synchronous channel).
     * <br>
     * Attention: Has to be called after XL_MOST150_STREAM_STATE "Started" was received.
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_STATE
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamStop(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1724</i>
     */
    short xlMost150StreamStop(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Provides further streaming data to be sent to the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_TX_BUFFER as soon as further data is required.
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param pBuffer                    [IN] pointer to the buffer used for streaming
     * <br>
     * \param pNumberOfBytes       [IN]/[OUT] number of bytes contained in the buffer to be used for streaming.
     * <br>
     * In case of not all bytes could be stored, this parameters contains the adjusted
     * <br>
     * number of bytes stored and the function returns an error (XL_ERR_QUEUE_IS_FULL).
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamTransmitData(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1739</i><br>
     *
     * @deprecated use the safer methods {@link #xlMost150StreamTransmitData(com.sun.jna.NativeLong, long, short, int, ByteBuffer, IntBuffer)} and {@link #xlMost150StreamTransmitData(com.sun.jna.NativeLong, long, short, int, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlMost150StreamTransmitData(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, Pointer pBuffer, IntByReference pNumberOfBytes);

    /**
     * \brief Provides further streaming data to be sent to the MOST bus (synchronous channel).
     * <br>
     * ResponseEvent:                         XL_MOST150_STREAM_TX_BUFFER as soon as further data is required.
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen
     * <br>
     * \param pBuffer                    [IN] pointer to the buffer used for streaming
     * <br>
     * \param pNumberOfBytes       [IN]/[OUT] number of bytes contained in the buffer to be used for streaming.
     * <br>
     * In case of not all bytes could be stored, this parameters contains the adjusted
     * <br>
     * number of bytes stored and the function returns an error (XL_ERR_QUEUE_IS_FULL).
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamTransmitData(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned char*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1739</i>
     */
    short xlMost150StreamTransmitData(NativeLong portHandle, long accessMask, short userHandle, int streamHandle, ByteBuffer pBuffer, IntBuffer pNumberOfBytes);

    /**
     * \brief Clears the content of the driver's Tx FIFO.
     * <br>
     * This method is used to clear the content of the driver's TX streaming FIFO which has not been sent yet.\n
     * <br>
     * ResponseEvent:                         None
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param streamHandle               [IN] stream handle returned by xlMostStreamOpen.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamClearTxFifo(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1752</i>
     */
    short xlMost150StreamClearTxFifo(NativeLong portHandle, long accessMask, short userHandle, int streamHandle);

    /**
     * \brief Retrieves the stream information.
     * <br>
     * This method is used to gather the recent stream state information.\n
     * <br>
     * ResponseEvent:                         None
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel from where to get the device's state
     * <br>
     * \param userHandle                 [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param pStreamInfo               [OUT] Pointer to the stream information.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamGetInfo(XLportHandle, XLaccess, unsigned short, XLmost150StreamInfo*)</code><br>
     * <i>native declaration : vxlapi.h:1764</i>
     */
    short xlMost150StreamGetInfo(NativeLong portHandle, long accessMask, short userHandle, s_xl_most150_stream_get_info pStreamInfo);

    /**
     * \brief Initializes the Rx Streaming FIFO.
     * <br>
     * This method is used to initialize the FIFO for storing the received streaming data.\n
     * <br>
     * ResponseEvent:                         None
     * <br>
     * \param portHandle                 [IN] handle to port from which the information is requested
     * <br>
     * \param accessMask                 [IN] specifies the port's channel
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamInitRxFifo(XLportHandle, XLaccess)</code><br>
     * <i>native declaration : vxlapi.h:1773</i>
     */
    short xlMost150StreamInitRxFifo(NativeLong portHandle, long accessMask);

    /**
     * \brief Fetches streaming data from the driver queue.
     * <br>
     * This method is used to fetch received streaming data. The application is triggered by
     * <br>
     * a XL_MOST150_STREAM_RX_BUFFER event to call this method.
     * <br>
     * It is a synchronous mode and either delivers streaming data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  pBuffer                   [IN] Pointer to a buffer to which the driver can copy
     * <br>
     * the streaming data of the receive queue
     * <br>
     * \param  pBufferSize               [IN] Determines the maximum buffer size
     * <br>
     * [OUT] The number of actually copied data bytes
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamReceiveData(XLportHandle, XLaccess, unsigned char*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1788</i><br>
     *
     * @deprecated use the safer methods {@link #xlMost150StreamReceiveData(com.sun.jna.NativeLong, long, ByteBuffer, IntBuffer)} and {@link #xlMost150StreamReceiveData(com.sun.jna.NativeLong, long, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlMost150StreamReceiveData(NativeLong portHandle, long accessMask, Pointer pBuffer, IntByReference pBufferSize);

    /**
     * \brief Fetches streaming data from the driver queue.
     * <br>
     * This method is used to fetch received streaming data. The application is triggered by
     * <br>
     * a XL_MOST150_STREAM_RX_BUFFER event to call this method.
     * <br>
     * It is a synchronous mode and either delivers streaming data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  pBuffer                   [IN] Pointer to a buffer to which the driver can copy
     * <br>
     * the streaming data of the receive queue
     * <br>
     * \param  pBufferSize               [IN] Determines the maximum buffer size
     * <br>
     * [OUT] The number of actually copied data bytes
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150StreamReceiveData(XLportHandle, XLaccess, unsigned char*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1788</i>
     */
    short xlMost150StreamReceiveData(NativeLong portHandle, long accessMask, ByteBuffer pBuffer, IntBuffer pBufferSize);

    /**
     * \brief Controls the bypass stress generation.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  bypassCloseTime           [IN] duration of bypass close time in [ms] (minimum value: 10 ms)
     * <br>
     * \param  bypassOpenTime            [IN] duration of bypass open time in [ms] (minimum value: 10 ms)
     * <br>
     * \param  repeat                    [IN] number of error intervals
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GenerateBypassStress(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1801</i>
     */
    short xlMost150GenerateBypassStress(NativeLong portHandle, long accessMask, short userHandle, int bypassCloseTime, int bypassOpenTime, int repeat);

    /**
     * \brief Configures a sequence for the ECL.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  numStates                 [IN] Number of states during the sequence (max. XL_MOST150_ECL_SEQ_NUM_STATES_MAX)
     * <br>
     * \param  pEclStates                [IN] Pointer to a buffer containing the ECL sequence states (1: High, 0: Low)
     * <br>
     * \param  pEclStatesDuration        [IN] Pointer to a buffer containing the ECL sequence states duration in multiple of 100 us (max. value
     * <br>
     * XL_MOST150_ECL_SEQ_DURATION_MAX) NOTE: Both buffers have to have at least the size <numStates> DWORDS! \return XLstatus general status
     * <br>
     * information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150EclConfigureSeq(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1815</i><br>
     *
     * @deprecated use the safer methods {@link #xlMost150EclConfigureSeq(com.sun.jna.NativeLong, long, short, int, IntBuffer, IntBuffer)} and {@link #xlMost150EclConfigureSeq(com.sun.jna.NativeLong, long, short, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlMost150EclConfigureSeq(NativeLong portHandle, long accessMask, short userHandle, int numStates, IntByReference pEclStates, IntByReference pEclStatesDuration);

    /**
     * \brief Configures a sequence for the ECL.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  numStates                 [IN] Number of states during the sequence (max. XL_MOST150_ECL_SEQ_NUM_STATES_MAX)
     * <br>
     * \param  pEclStates                [IN] Pointer to a buffer containing the ECL sequence states (1: High, 0: Low)
     * <br>
     * \param  pEclStatesDuration        [IN] Pointer to a buffer containing the ECL sequence states duration in multiple of 100 us (max. value
     * <br>
     * XL_MOST150_ECL_SEQ_DURATION_MAX) NOTE: Both buffers have to have at least the size <numStates> DWORDS! \return XLstatus general status
     * <br>
     * information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150EclConfigureSeq(XLportHandle, XLaccess, unsigned short, unsigned int, unsigned int*, unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:1815</i>
     */
    short xlMost150EclConfigureSeq(NativeLong portHandle, long accessMask, short userHandle, int numStates, IntBuffer pEclStates, IntBuffer pEclStatesDuration);

    /**
     * \brief Starts or stops the previously configured ECL sequence.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  start                     [IN] Starts (1) or stops (0) the configured ECL sequence
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150EclGenerateSeq(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1826</i>
     */
    short xlMost150EclGenerateSeq(NativeLong portHandle, long accessMask, short userHandle, int start);

    /**
     * \brief Configures the glitch filter for detecting ECL state changes.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  duration                  [IN] Duration (in us) of glitches to be filtered. Value range: 50 us .. 50 ms (Default: 1 ms)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetECLGlitchFilter(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1836</i>
     */
    short xlMost150SetECLGlitchFilter(NativeLong portHandle, long accessMask, short userHandle, int duration);

    /**
     * \brief Sets the SSOResult value - needed for resetting the value to 0x00 (No Result) after Shutdown Result analysis has been done.
     * <br>
     * ResponseEvent:                         XL_MOST150_SSO_RESULT.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \param  ssoCUStatus               [IN] SSOCUStatus (currently only the value <XL_MOST150_SSO_RESULT_NO_RESULT> is allowed!)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150SetSSOResult(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1848</i>
     */
    short xlMost150SetSSOResult(NativeLong portHandle, long accessMask, short userHandle, int ssoCUStatus);

    /**
     * \brief Requests the SSOResult value.
     * <br>
     * ResponseEvent:                         XL_MOST150_SSO_RESULT.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  XLaccess accessMask:      [IN] determines on which channel an API should work
     * <br>
     * \param  XLuserHandle userHandle:  [IN] used to match the response of the driver to the requests of the application
     * <br>
     * if an event is received spontaneously
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlMost150GetSSOResult(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1858</i>
     */
    short xlMost150GetSSOResult(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Configures basic Ethernet settings.
     * <br>
     * This method is used to configure the basic Ethernets settings like speed, connector, etc. \n
     * <br>
     * ResponseEvent:                         XL_ETH_CONFIG_RESULT
     * <br>
     * \param  config                    [IN] new configuration to set
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthSetConfig(XLportHandle, XLaccess, unsigned short, const T_XL_ETH_CONFIG*)</code><br>
     * <i>native declaration : vxlapi.h:1887</i>
     */
    short xlEthSetConfig(NativeLong portHandle, long accessMask, short userHandle, T_XL_ETH_CONFIG config);

    /**
     * \brief Synchronously read the last Ethernet configuration settings.
     * <br>
     * This allows an application to detect if a change in configuration is necessary.\n
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \param  config                   [OUT] current configuration
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthGetConfig(XLportHandle, XLaccess, unsigned short, T_XL_ETH_CONFIG*)</code><br>
     * <i>native declaration : vxlapi.h:1895</i>
     */
    short xlEthGetConfig(NativeLong portHandle, long accessMask, short userHandle, T_XL_ETH_CONFIG config);

    /**
     * \brief Fetching events from driver queue.
     * <br>
     * This method is used to fetch events, either bus events or acknowledgments
     * <br>
     * for commands from the driver queue. Each call delivers only one event (if an event is available). \n
     * <br>
     * It is a synchronous mode and either delivers event data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  XLportHandle portHandle:  [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  ethEventBuffer            [IN] This parameter must point to a buffer to which the driver can copy
     * <br>
     * the next event of the receive queue. The "size" member of this struct
     * <br>
     * specifies the maximum size of the buffer (header plus receive data); upon return,
     * <br>
     * it holds the actual size.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthReceive(XLportHandle, T_XL_ETH_EVENT*)</code><br>
     * <i>native declaration : vxlapi.h:1909</i>
     */
    short xlEthReceive(NativeLong portHandle, s_xl_eth_event ethEventBuffer);

    /**
     * \brief Configures the bypass of two channels.
     * <br>
     * This method is used to enable the bypass of two channels or to disable the bypass for several channels\n
     * <br>
     * ResponseEvent:                         XL_ETH_CONFIG
     * <br>
     * \param  mode                      [IN] Bypass state (one of XL_ETH_BYPASS_INACTIVE, XL_ETH_BYPASS_PHY, XL_ETH_BYPASS_MACCORE)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthSetBypass(XLportHandle, XLaccess, unsigned short, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1917</i>
     */
    short xlEthSetBypass(NativeLong portHandle, long accessMask, short userHandle, int mode);

    /**
     * \brief Twinkle the Status led from the VN5610.
     * <br>
     * ResponseEvent:                         none
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthTwinkleStatusLed(XLportHandle, XLaccess, unsigned short)</code><br>
     * <i>native declaration : vxlapi.h:1924</i>
     */
    short xlEthTwinkleStatusLed(NativeLong portHandle, long accessMask, short userHandle);

    /**
     * \brief Transmit a data frame to the network.
     * <br>
     * This method is asynchronous; a confirmation of the transmit is received via an XL_ETH_TX_OK/XL_ETH_TX_ERROR event.
     * <br>
     * ResponseEvent:                         XL_ETH_TX_OK, XL_ETH_TX_ERROR
     * <br>
     * \param  data:                     [IN] pointer to an Ethernet data frame to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlEthTransmit(XLportHandle, XLaccess, unsigned short, const T_XL_ETH_DATAFRAME_TX*)</code><br>
     * <i>native declaration : vxlapi.h:1932</i>
     */
    short xlEthTransmit(NativeLong portHandle, long accessMask, short userHandle, s_xl_eth_dataframe_tx data);

    /**
     * xlNetEthOpenNetwork
     * <br>
     * \brief Creates a network queue defined by accessType.
     * <br>
     * \param pNetworkName   [IN]  Network name
     * <br>
     * \param pNetworkHandle [OUT] Network handle
     * <br>
     * \param pAppName       [IN]  Application name
     * <br>
     * \param accessType     [IN]  Access type for the RX FIFO
     * <br>
     * \param queueSize      [IN]  RX FIFO size in bytes
     * <br>
     * \return XLstatus      general status information
     * <br>
     * <br>
     * <br>
     * When done, the application must call  network  xlNetCloseNetwork() to release
     * <br>
     * the allocated handle.<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthOpenNetwork(const char*, XLnetworkHandle*, const char*, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1952</i><br>
     *
     * @deprecated use the safer methods {@link #xlNetEthOpenNetwork(String, com.sun.jna.ptr.NativeLongByReference, String, int, int)} and {@link #xlNetEthOpenNetwork(com.sun.jna.Pointer, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    short xlNetEthOpenNetwork(Pointer pNetworkName, NativeLongByReference pNetworkHandle, Pointer pAppName, int accessType, int queueSize);

    /**
     * xlNetEthOpenNetwork
     * <br>
     * \brief Creates a network queue defined by accessType.
     * <br>
     * \param pNetworkName   [IN]  Network name
     * <br>
     * \param pNetworkHandle [OUT] Network handle
     * <br>
     * \param pAppName       [IN]  Application name
     * <br>
     * \param accessType     [IN]  Access type for the RX FIFO
     * <br>
     * \param queueSize      [IN]  RX FIFO size in bytes
     * <br>
     * \return XLstatus      general status information
     * <br>
     * <br>
     * <br>
     * When done, the application must call  network  xlNetCloseNetwork() to release
     * <br>
     * the allocated handle.<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthOpenNetwork(const char*, XLnetworkHandle*, const char*, unsigned int, unsigned int)</code><br>
     * <i>native declaration : vxlapi.h:1952</i>
     */
    short xlNetEthOpenNetwork(String pNetworkName, NativeLongByReference pNetworkHandle, String pAppName, int accessType, int queueSize);

    /**
     * xlNetCloseNetwork
     * <br>
     * \brief Close network and delete RX queue.
     * <br>
     * \param networkHandle [IN]  Network handle allocated by xlNetEthOpenNetwork
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetCloseNetwork(XLnetworkHandle)</code><br>
     * <i>native declaration : vxlapi.h:1962</i>
     */
    short xlNetCloseNetwork(NativeLong networkHandle);

    /**
     * xlNetOpenVirtualPort
     * <br>
     * \brief Connect a virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pVPortName    [IN]  Virtual port name to connect
     * <br>
     * \param pEthPortHandle[OUT] Virtual port handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetOpenVirtualPort(XLnetworkHandle, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:1973</i><br>
     *
     * @deprecated use the safer methods {@link #xlNetOpenVirtualPort(com.sun.jna.NativeLong, String, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} and {@link #xlNetOpenVirtualPort(com.sun.jna.NativeLong, com.sun.jna.Pointer, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} instead
     */
    @Deprecated
    short xlNetOpenVirtualPort(NativeLong networkHandle, Pointer pVPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetOpenVirtualPort
     * <br>
     * \brief Connect a virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pVPortName    [IN]  Virtual port name to connect
     * <br>
     * \param pEthPortHandle[OUT] Virtual port handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetOpenVirtualPort(XLnetworkHandle, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:1973</i>
     */
    short xlNetOpenVirtualPort(NativeLong networkHandle, String pVPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetAddVirtualPort
     * <br>
     * \brief Add a virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pSwitchName   [IN]  Switch name
     * <br>
     * \param pVPortName    [IN]  Virtual port name to add
     * <br>
     * \param pEthPortHandle[OUT] Virtual port handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetAddVirtualPort(XLnetworkHandle, const char*, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:1986</i><br>
     *
     * @deprecated use the safer methods {@link #xlNetAddVirtualPort(com.sun.jna.NativeLong, String, String, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} and {@link #xlNetAddVirtualPort(com.sun.jna.NativeLong, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} instead
     */
    @Deprecated
    short xlNetAddVirtualPort(NativeLong networkHandle, Pointer pSwitchName, Pointer pVPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetAddVirtualPort
     * <br>
     * \brief Add a virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pSwitchName   [IN]  Switch name
     * <br>
     * \param pVPortName    [IN]  Virtual port name to add
     * <br>
     * \param pEthPortHandle[OUT] Virtual port handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetAddVirtualPort(XLnetworkHandle, const char*, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:1986</i>
     */
    short xlNetAddVirtualPort(NativeLong networkHandle, String pSwitchName, String pVPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetConnectMeasurementPoint
     * <br>
     * \brief Connect the application with a pre-defined measurement point or
     * <br>
     * add a measurement point to a pre-defined virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pPortName     [IN]  Measurement point name or virtual port to connect
     * <br>
     * \param pEthPortHandle[OUT] Measurement point handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetConnectMeasurementPoint(XLnetworkHandle, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:2000</i><br>
     *
     * @deprecated use the safer methods {@link #xlNetConnectMeasurementPoint(com.sun.jna.NativeLong, String, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} and {@link #xlNetConnectMeasurementPoint(com.sun.jna.NativeLong, com.sun.jna.Pointer, com.sun.jna.ptr.NativeLongByReference, com.sun.jna.NativeLong)} instead
     */
    @Deprecated
    short xlNetConnectMeasurementPoint(NativeLong networkHandle, Pointer pPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetConnectMeasurementPoint
     * <br>
     * \brief Connect the application with a pre-defined measurement point or
     * <br>
     * add a measurement point to a pre-defined virtual port.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param pPortName     [IN]  Measurement point name or virtual port to connect
     * <br>
     * \param pEthPortHandle[OUT] Measurement point handle
     * <br>
     * \param rxHandle      [IN]  Application defined RX handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetConnectMeasurementPoint(XLnetworkHandle, const char*, XLethPortHandle*, XLrxHandle)</code><br>
     * <i>native declaration : vxlapi.h:2000</i>
     */
    short xlNetConnectMeasurementPoint(NativeLong networkHandle, String pPortName, NativeLongByReference pEthPortHandle, NativeLong rxHandle);

    /**
     * xlNetActivateNetwork
     * <br>
     * \brief Activate the network and enable event reception.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \return XLstatus     general status information
     * <br>
     * <br>
     * The receive queue is implicitly flushed by this function.<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetActivateNetwork(XLnetworkHandle)</code><br>
     * <i>native declaration : vxlapi.h:2011</i>
     */
    short xlNetActivateNetwork(NativeLong networkHandle);

    /**
     * xlNetDeactivateNetwork
     * <br>
     * \brief Deactivate the network and disable event reception.
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetDeactivateNetwork(XLnetworkHandle)</code><br>
     * <i>native declaration : vxlapi.h:2019</i>
     */
    short xlNetDeactivateNetwork(NativeLong networkHandle);

    /**
     * xlNetEthSend
     * <br>
     * \brief Send an Ethernet frame via a virtual or physical port
     * <br>
     * \param networkHandle [IN]  Network handle
     * <br>
     * \param ethPortHandle [IN]  Port handle
     * <br>
     * \param userHandle    [IN]  Application specific handle
     * <br>
     * \param pEthTxFrame   [IN]  Frame to send
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthSend(XLnetworkHandle, XLethPortHandle, unsigned short, const T_XL_NET_ETH_DATAFRAME_TX*)</code><br>
     * <i>native declaration : vxlapi.h:2030</i>
     */
    short xlNetEthSend(NativeLong networkHandle, NativeLong ethPortHandle, short userHandle, s_xl_eth_dataframe_tx pEthTxFrame);

    /**
     * xlNetEthReceive
     * <br>
     * \brief Receive an Ethernet event from the network.
     * <br>
     * \param networkHandle  [IN]  Network handle
     * <br>
     * \param pEventBuffer   [OUT] Event received
     * <br>
     * \param pRxHandleCount [IN/OUT] Number of RX handles in list
     * <br>
     * \param pRxHandle      [OUT] RX handle list
     * <br>
     * \return XLstatus      general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthReceive(XLnetworkHandle, T_XL_NET_ETH_EVENT*, unsigned int*, XLrxHandle*)</code><br>
     * <i>native declaration : vxlapi.h:2043</i><br>
     *
     * @deprecated use the safer methods {@link #xlNetEthReceive(com.sun.jna.NativeLong, s_xl_net_eth_event, IntBuffer, com.sun.jna.ptr.NativeLongByReference)} and {@link #xlNetEthReceive(com.sun.jna.NativeLong, s_xl_net_eth_event, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.NativeLongByReference)} instead
     */
    @Deprecated
    short xlNetEthReceive(NativeLong networkHandle, s_xl_net_eth_event pEventBuffer, IntByReference pRxHandleCount, NativeLongByReference pRxHandle);

    /**
     * xlNetEthReceive
     * <br>
     * \brief Receive an Ethernet event from the network.
     * <br>
     * \param networkHandle  [IN]  Network handle
     * <br>
     * \param pEventBuffer   [OUT] Event received
     * <br>
     * \param pRxHandleCount [IN/OUT] Number of RX handles in list
     * <br>
     * \param pRxHandle      [OUT] RX handle list
     * <br>
     * \return XLstatus      general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthReceive(XLnetworkHandle, T_XL_NET_ETH_EVENT*, unsigned int*, XLrxHandle*)</code><br>
     * <i>native declaration : vxlapi.h:2043</i>
     */
    short xlNetEthReceive(NativeLong networkHandle, s_xl_net_eth_event pEventBuffer, IntBuffer pRxHandleCount, NativeLongByReference pRxHandle);

    /**
     * xlNetEthRequestChannelStatus
     * <br>
     * \brief Queries the current channel (real port) status on the whole network.
     * <br>
     * Asynchronous request for the event that indicates the current status.
     * <br>
     * ResponseEvent:             XL_ETH_CHANNEL_STATUS
     * <br>
     * \param networkHandle [IN]  Network handle (Control)
     * <br>
     * \return XLstatus           General status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetEthRequestChannelStatus(XLnetworkHandle)</code><br>
     * <i>native declaration : vxlapi.h:2054</i>
     */
    short xlNetEthRequestChannelStatus(NativeLong networkHandle);

    /**
     * xlNetSetNotification
     * <br>
     * \brief Setup an event to notify the application if there are messages in the
     * <br>
     * Ethernet network receive queue.
     * <br>
     * Note that the event is triggered only once, when the queueLevel is reached.
     * <br>
     * An application should read all available messages by xlNetEthReceive to be sure
     * <br>
     * to re enable the event.
     * <br>
     * \param networkHandle [IN]  Network handle (Receive Queue)
     * <br>
     * \param pHandle       [OUT] Generated handle
     * <br>
     * \param queueLevel    [IN]  Specifies the number of bytes that triggers the event
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetSetNotification(XLnetworkHandle, XLhandle*, int)</code><br>
     * <i>native declaration : vxlapi.h:2068</i><br>
     *
     * @deprecated use the safer method {@link #xlNetSetNotification(com.sun.jna.NativeLong, com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    short xlNetSetNotification(NativeLong networkHandle, Pointer pHandle, int queueLevel);

    /**
     * xlNetSetNotification
     * <br>
     * \brief Setup an event to notify the application if there are messages in the
     * <br>
     * Ethernet network receive queue.
     * <br>
     * Note that the event is triggered only once, when the queueLevel is reached.
     * <br>
     * An application should read all available messages by xlNetEthReceive to be sure
     * <br>
     * to re enable the event.
     * <br>
     * \param networkHandle [IN]  Network handle (Receive Queue)
     * <br>
     * \param pHandle       [OUT] Generated handle
     * <br>
     * \param queueLevel    [IN]  Specifies the number of bytes that triggers the event
     * <br>
     * \return XLstatus     general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetSetNotification(XLnetworkHandle, XLhandle*, int)</code><br>
     * <i>native declaration : vxlapi.h:2068</i>
     */
    short xlNetSetNotification(NativeLong networkHandle, PointerByReference pHandle, int queueLevel);

    /**
     * xlNetRequestMACAddress
     * <br>
     * \brief Request and lock a globally-unique ETH MAC address from
     * <br>
     * pool of application-reservable MAC addresses in the network.
     * <br>
     * <br>
     * The pool of the network is the union of all the MAC-pools of the
     * <br>
     * devices that are part of the network. When the networkHandle is closed
     * <br>
     * - or when the application terminates - the MAC address is implicitly
     * <br>
     * released. While a MAC address is locked, no other application can
     * <br>
     * request the address.
     * <br>
     * <br>
     * \param networkHandle  [IN]  Network handle (Control)
     * <br>
     * \param pMACAddress    [OUT] Structure to retrieve ETH MAC address
     * <br>
     * \return XLstatus     general status information
     * <br>
     * <br>
     * XL_SUCCESS if reservation of MAC address succeeded
     * <br>
     * XL_ERR_NO_RESOURCES if the pool of on-demand allocatable  MAC addresses
     * <br>
     * of all devices in the network is exhausted
     * <br>
     * XL_ERR_NOT_SUPPORTED if no device in the network has a pool of
     * <br>
     * demand-allocatable MAC addresses<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetRequestMACAddress(XLnetworkHandle, T_XL_ETH_MAC_ADDRESS*)</code><br>
     * <i>native declaration : vxlapi.h:2091</i>
     */
    short xlNetRequestMACAddress(NativeLong networkHandle, T_XL_ETH_MAC_ADDRESS pMACAddress);

    /**
     * xlNetReleaseMACAddress
     * <br>
     * \brief Release a former requested ETH MAC address from the pool of
     * <br>
     * all application-reservable MAC addresses in the network.
     * <br>
     * \param networkHandle [IN]  Network handle (Control)
     * <br>
     * \param MACAddress    [IN]  Structure with ETH MAC address to release
     * <br>
     * \return XLstatus           general status information
     * <br>
     * <br>
     * XL_SUCCESS if MAC address was successully released
     * <br>
     * XL_ERR_NOT_FOUND the given MAC address has not been reserved via the
     * <br>
     * given networkHandle (or has already been released).
     * <br>
     * XL_ERR_NOT_SUPPORTED if no device in the network has a pool of
     * <br>
     * demand-allocatable MAC addresses<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetReleaseMACAddress(XLnetworkHandle, const T_XL_ETH_MAC_ADDRESS*)</code><br>
     * <i>native declaration : vxlapi.h:2107</i>
     */
    short xlNetReleaseMACAddress(NativeLong networkHandle, T_XL_ETH_MAC_ADDRESS pMACAddress);

    /**
     * xlNetFlushReceiveQueue
     * <br>
     * \brief Flush the application receive queue.
     * <br>
     * \param networkHandle [IN]  Network handle (Receive Queue)
     * <br>
     * \return XLstatus           general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlNetFlushReceiveQueue(XLnetworkHandle)</code><br>
     * <i>native declaration : vxlapi.h:2116</i>
     */
    short xlNetFlushReceiveQueue(NativeLong networkHandle);

    /**
     * \brief Fetching events from driver queue.
     * <br>
     * This method is used to fetch events, either bus events or acknowledgments
     * <br>
     * for commands from the driver queue. Each call delivers only one event (if an event is available). \n
     * <br>
     * It is a synchronous mode and either delivers event data immediately, or
     * <br>
     * indicates an error condition with its return value.
     * <br>
     * \param  portHandle:               [IN] was previously fetched by xlOpenPort API
     * <br>
     * \param  pXlA429RxEvt:             [IN] This parameter must point to a buffer to which the driver can copy
     * <br>
     * the next event of the receive queue. The "size" member of this struct
     * <br>
     * specifies the maximum size of the buffer (header plus receive data); upon return,
     * <br>
     * it holds the actual size.
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlA429Receive(XLportHandle, XLa429RxEvent*)</code><br>
     * <i>native declaration : vxlapi.h:2143</i>
     */
    short xlA429Receive(NativeLong portHandle, XLa429RxEvent pXlA429RxEvt);

    /**
     * \brief Configures basic Arinc429 settings.
     * <br>
     * This method is used to configure the basic Arinc429 settings like parity, bitrate, etc. \n
     * <br>
     * \param  pXlA429Params:            [IN] new Arinc429 parameter to set
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlA429SetChannelParams(XLportHandle, XLaccess, XL_A429_PARAMS*)</code><br>
     * <i>native declaration : vxlapi.h:2150</i>
     */
    short xlA429SetChannelParams(NativeLong portHandle, long accessMask, s_xl_a429_params pXlA429Params);

    /**
     * \brief Transmit a Arinc429 uint16_t to the network.
     * <br>
     * This method is asynchronous; a confirmation of the transmit is received via an XL_A429_EV_TAG_TX_OK/XL_A429_EV_TAG_TX_ERR event.
     * <br>
     * \param  pXlA429MsgTx:             [IN] pointer to an Arinc429 frame to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlA429Transmit(XLportHandle, XLaccess, unsigned int, unsigned int*, XL_A429_MSG_TX*)</code><br>
     * <i>native declaration : vxlapi.h:2157</i><br>
     *
     * @deprecated use the safer methods {@link #xlA429Transmit(com.sun.jna.NativeLong, long, int, IntBuffer, s_xl_a429_msg_tx)} and {@link #xlA429Transmit(com.sun.jna.NativeLong, long, int, com.sun.jna.ptr.IntByReference, s_xl_a429_msg_tx)} instead
     */
    @Deprecated
    short xlA429Transmit(NativeLong portHandle, long accessMask, int msgCnt, IntByReference pMsgCntSent, s_xl_a429_msg_tx pXlA429MsgTx);

    /**
     * \brief Transmit a Arinc429 uint16_t to the network.
     * <br>
     * This method is asynchronous; a confirmation of the transmit is received via an XL_A429_EV_TAG_TX_OK/XL_A429_EV_TAG_TX_ERR event.
     * <br>
     * \param  pXlA429MsgTx:             [IN] pointer to an Arinc429 frame to be sent
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlA429Transmit(XLportHandle, XLaccess, unsigned int, unsigned int*, XL_A429_MSG_TX*)</code><br>
     * <i>native declaration : vxlapi.h:2157</i>
     */
    short xlA429Transmit(NativeLong portHandle, long accessMask, int msgCnt, IntBuffer pMsgCntSent, s_xl_a429_msg_tx pXlA429MsgTx);

    /**
     * \brief Returns connected Keyman license dongles.
     * <br>
     * This method returns the connected Keyman license dongles
     * <br>
     * \param  boxCount:                 [IN] number of connected Keyman license Dongles
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetKeymanBoxes(unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:2170</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetKeymanBoxes(IntBuffer)} and {@link #xlGetKeymanBoxes(com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    short xlGetKeymanBoxes(IntByReference boxCount);

    /**
     * \brief Returns connected Keyman license dongles.
     * <br>
     * This method returns the connected Keyman license dongles
     * <br>
     * \param  boxCount:                 [IN] number of connected Keyman license Dongles
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetKeymanBoxes(unsigned int*)</code><br>
     * <i>native declaration : vxlapi.h:2170</i>
     */
    short xlGetKeymanBoxes(IntBuffer boxCount);

    /**
     * \brief Returns serial number and license info.
     * <br>
     * This method returns serial number and license info (license bits) of selected Keyman License dongle
     * <br>
     * \param  boxIndex:                 [IN] index of found Keyman License Dongle (zero based)
     * <br>
     * \param  boxMask:                  [OUT] mask of Keyman Dongle
     * <br>
     * \param  boxSerial:                [OUT] serial number of Keyman Dongle
     * <br>
     * \param  licInfo:                  [OUT] license Info (license bits in license array)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetKeymanInfo(unsigned int, unsigned int*, unsigned int*, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:2180</i><br>
     *
     * @deprecated use the safer methods {@link #xlGetKeymanInfo(int, IntBuffer, IntBuffer, LongBuffer)} and {@link #xlGetKeymanInfo(int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.LongByReference)} instead
     */
    @Deprecated
    short xlGetKeymanInfo(int boxIndex, IntByReference boxMask, IntByReference boxSerial, LongByReference licInfo);

    /**
     * \brief Returns serial number and license info.
     * <br>
     * This method returns serial number and license info (license bits) of selected Keyman License dongle
     * <br>
     * \param  boxIndex:                 [IN] index of found Keyman License Dongle (zero based)
     * <br>
     * \param  boxMask:                  [OUT] mask of Keyman Dongle
     * <br>
     * \param  boxSerial:                [OUT] serial number of Keyman Dongle
     * <br>
     * \param  licInfo:                  [OUT] license Info (license bits in license array)
     * <br>
     * \return XLstatus                       general status information<br>
     * Original signature : <code>__attribute__((dllexport)) XLstatus xlGetKeymanInfo(unsigned int, unsigned int*, unsigned int*, XLuint64*)</code><br>
     * <i>native declaration : vxlapi.h:2180</i>
     */
    short xlGetKeymanInfo(int boxIndex, IntBuffer boxMask, IntBuffer boxSerial, LongBuffer licInfo);

    /**
     * <i>native declaration : vxlapi.h:369</i><br>
     * enum values
     */
    public static interface e_XLevent_type {
        /**
         * <i>native declaration : vxlapi.h:370</i>
         */
        public static final int XL_NO_COMMAND = 0;
        /**
         * <i>native declaration : vxlapi.h:371</i>
         */
        public static final int XL_RECEIVE_MSG = 1;
        /**
         * <i>native declaration : vxlapi.h:372</i>
         */
        public static final int XL_CHIP_STATE = 4;
        /**
         * <i>native declaration : vxlapi.h:373</i>
         */
        public static final int XL_TRANSCEIVER = 6;
        /**
         * <i>native declaration : vxlapi.h:374</i>
         */
        public static final int XL_TIMER = 8;
        /**
         * <i>native declaration : vxlapi.h:375</i>
         */
        public static final int XL_TRANSMIT_MSG = 10;
        /**
         * <i>native declaration : vxlapi.h:376</i>
         */
        public static final int XL_SYNC_PULSE = 11;
        /**
         * <i>native declaration : vxlapi.h:377</i>
         */
        public static final int XL_APPLICATION_NOTIFICATION = 15;
        /**
         * for LIN we have special events<br>
         * <i>native declaration : vxlapi.h:381</i>
         */
        public static final int XL_LIN_MSG = 20;
        /**
         * <i>native declaration : vxlapi.h:382</i>
         */
        public static final int XL_LIN_ERRMSG = 21;
        /**
         * <i>native declaration : vxlapi.h:383</i>
         */
        public static final int XL_LIN_SYNCERR = 22;
        /**
         * <i>native declaration : vxlapi.h:384</i>
         */
        public static final int XL_LIN_NOANS = 23;
        /**
         * <i>native declaration : vxlapi.h:385</i>
         */
        public static final int XL_LIN_WAKEUP = 24;
        /**
         * <i>native declaration : vxlapi.h:386</i>
         */
        public static final int XL_LIN_SLEEP = 25;
        /**
         * <i>native declaration : vxlapi.h:387</i>
         */
        public static final int XL_LIN_CRCINFO = 26;
        /**
         * for D/A IO bus<br>
         * !< D/A IO data message<br>
         * <i>native declaration : vxlapi.h:390</i>
         */
        public static final int XL_RECEIVE_DAIO_DATA = 32;
        /**
         * !< D/A IO Piggy data message<br>
         * <i>native declaration : vxlapi.h:392</i>
         */
        public static final int XL_RECEIVE_DAIO_PIGGY = 34;
        /**
         * <i>native declaration : vxlapi.h:393</i>
         */
        public static final int XL_KLINE_MSG = 36;
    }

    /**
     * <i>native declaration : vxlapi.h</i><br>
     * enum values
     */
    public static interface XLnetworkType {
        /**
         * <i>native declaration : vxlapi.h:128</i>
         */
        public static final int XL_ETH_NETWORK = 1;
    }

    /**
     * <i>native declaration : vxlapi.h</i><br>
     * enum values
     */
    public static interface XLIdriverConfigVersion {
        /**
         * <i>native declaration : vxlapi.h:159</i>
         */
        public static final int XL_IDRIVER_CONFIG_VERSION_1 = 0x8001;
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_CHANNEL_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_channel_drv_config_list_v1 channelCfgList);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_DEVICE_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_device_drv_config_list_v1 deviceCfgList);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_VIRTUAL_PORT_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_virtual_port_drv_config_list_v1 virtualPortCfgList);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_MEASUREMENT_POINT_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_xl_measurement_point_drv_config_list_v1 measurementPointCfg);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_SWITCH_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_switch_drv_config_list_v1 switchCfgList);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_NETWORK_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_xl_network_drv_config_list_v1 networkCfgList);
    }

    /**
     * <i>native declaration : vxlapi.h</i>
     */
    public interface TP_FCT_XLAPI_GET_DLL_CONFIG_V1 extends StdCallLibrary.StdCallCallback {
        short apply(Pointer configHandle, s_xl_dll_drv_config_v1 dllCfg);
    }

    public static class XLdrvConfigHandle extends PointerType {
        public XLdrvConfigHandle(Pointer address) {
            super(address);
        }

        public XLdrvConfigHandle() {
            super();
        }
    }

    ;

    public static class XL_MOST_STREAM_BUFFER_EV extends PointerType {
        public XL_MOST_STREAM_BUFFER_EV(Pointer address) {
            super(address);
        }

        public XL_MOST_STREAM_BUFFER_EV() {
            super();
        }
    }

    ;

    public static class XLIDriverConfig extends PointerType {
        public XLIDriverConfig(Pointer address) {
            super(address);
        }

        public XLIDriverConfig() {
            super();
        }
    }

    ;

    public static class XLhandle extends PointerType {
        public XLhandle(Pointer address) {
            super(address);
        }

        public XLhandle() {
            super();
        }
    }

    ;
}
